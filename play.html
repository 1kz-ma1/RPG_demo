<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>å†’é™º</title>
    <link rel="stylesheet" href="static/rpg_style.css">
    <link rel="stylesheet" href="static/rpg_choice.css">
</head>
<body>
  <div class="layout">
    <div class="header">
      <h1 id="scene-title">âš” å†’é™º</h1>
      <div class="header-stats">
        
        <div class="stat">
          <span>LV</span>
          <span class="stat-value" id="level">1</span>
        </div>
        <div class="stat">
          <span>HP</span>
          <span class="stat-value" id="hp">100</span>
        </div>
        <div class="stat">
          <span>ã‚¹ã‚³ã‚¢</span>
          <span class="stat-value" id="score">0</span>
        </div>
        <div class="header-menu-btns">
          <button class="menu-btn" onclick="openStats()">ğŸ“Š ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</button>
          <button class="menu-btn" onclick="openInventory()">ğŸ’ ã‚¢ã‚¤ãƒ†ãƒ </button>
          <button class="menu-btn" onclick="openMap()">ğŸ—º ãƒãƒƒãƒ—</button>
        </div>
      </div>
    </div>
    
    <div class="scene">
      <div class="scene-image" id="scene-image">
        <img id="scene-img" src="" alt="scene" style="max-width:100%; max-height:100%; border-radius:2px; display:none;" />
        <span id="image-placeholder">ç”»åƒæº–å‚™ä¸­...</span>
        <div class="scene-text-overlay" id="scene-text-overlay" style="display:block;"></div>
      </div>
    </div>
    
    <div class="scene-log">
      <div class="log-title">ğŸ“œ ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div>
      <div id="log" style="max-height: 300px; overflow-y: auto;"></div>
    </div>
    
    <div class="choices" id="choices"></div>
    
    <div class="menu">
      <button class="menu-btn" onclick="goBack()" style="margin-left: auto;">â† æˆ»ã‚‹</button>
    </div>
  </div>

  <script>
              // é¸æŠè‚¢ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤º
              function showChoicesOverlay(choices, onSelect) {
                // æ—¢å­˜ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å‰Šé™¤
                const old = document.getElementById('scene-choice-overlay');
                if (old) old.remove();
                const overlay = document.createElement('div');
                overlay.className = 'scene-choice-overlay';
                overlay.id = 'scene-choice-overlay';
                overlay.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
                const list = document.createElement('div');
                list.className = 'scene-choice-list';
                list.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
                // resolve template variables in choice text (e.g. ${companion_name})
                const selComp = (function(){ try { return localStorage.getItem('selected_companion'); } catch(e){ return null; } })();
                const companionObj = selComp ? (function(){ try { return JSON.parse(selComp); } catch(e){ return null; } })() : null;
                const companionNameForBtn = (companionObj && companionObj.name) ? companionObj.name : 'ç›¸æ£’';
                const companionRoleForBtn = (companionObj && companionObj.role) ? companionObj.role : 'companion';
                const playerNameForBtn = (gameState && gameState.playerName) ? gameState.playerName : 'ä¸»äººå…¬';
                choices.forEach((choice, idx) => {
                  const btn = document.createElement('button');
                  btn.className = 'scene-choice-btn';
                  // replace known template vars safely
                  let txt = (choice.text || '');
                  try {
                    txt = txt.replace(/\$\{companion_name\}/g, companionNameForBtn).replace(/\$\{companion_role\}/g, companionRoleForBtn).replace(/\$\{player_name\}/g, playerNameForBtn);
                  } catch(e) {}
                  btn.textContent = txt;
                  btn.onclick = (e) => {
                    e.stopPropagation();
                    overlay.remove();
                    if (onSelect) onSelect(choice, idx);
                  };
                  list.appendChild(btn);
                });
                  overlay.appendChild(list);
                  // ç”»åƒãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é‡ã­ã¦è¿½åŠ 
                  const sceneImageDiv = document.getElementById('scene-image');
                  // showChoicesOverlay ã¯ typewriter ãŒçµ‚ã‚ã‚‹ã¾ã§å¾…æ©Ÿã™ã‚‹ï¼ˆå³è¡¨ç¤ºã‚’é˜²ãï¼‰
                  function attachOverlayWhenReady() {
                    // typing ãŒçµ‚ã‚ã‚‹ã¾ã§å¾…æ©Ÿã—ã¦ã‹ã‚‰è¡¨ç¤ºï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­ã‘ãšå³æ ¼ã«å¾…ã¤ï¼‰
                    function readyToAttach() {
                      const nextBtn = document.querySelector('.scene-text-next');
                      const nextVisible = nextBtn && nextBtn.style && nextBtn.style.display === 'block';
                      return !window.__isTyping && !nextVisible;
                    }
                    if (readyToAttach()) {
                      // å°ã•ãªä½™è£•æ™‚é–“ã‚’ç½®ã„ã¦ã‹ã‚‰å®Ÿéš›ã«è¿½åŠ ï¼ˆã‚¿ã‚¤ãƒ—çµ‚äº†ç›´å¾Œã®ç«¶åˆã‚’é¿ã‘ã‚‹ï¼‰
                      setTimeout(() => { if (readyToAttach() && sceneImageDiv) sceneImageDiv.appendChild(overlay); }, 160);
                      return;
                    }
                    const iv = setInterval(() => {
                      if (readyToAttach()) {
                        clearInterval(iv);
                        setTimeout(() => { if (readyToAttach() && sceneImageDiv) sceneImageDiv.appendChild(overlay); }, 160);
                      }
                    }, 50);
                  }
                  attachOverlayWhenReady();
              }
                  // typing ãƒ•ãƒ©ã‚°ï¼ˆå…¨ä½“ã® typewriter å®Ÿè¡Œä¸­ãƒ•ãƒ©ã‚°ï¼‰
                  window.__isTyping = window.__isTyping || false;
              // äº‹å‰å®šç¾©ã•ã‚ŒãŸæ•µä¸€è¦§ï¼ˆchoice.next ã« "battle:KEY" ã‚’æŒ‡å®šã—ãŸã¨ãã«ä½¿ç”¨ï¼‰
              const ENEMY_DEFS = {
                shadow: { id: 'shadow', name: 'é»’ãå½±', hp: 50, maxHp: 50, atk: 7, def: 1, avoid: 8, exp: 24, drops: [{name:'å°ã•ãªå›å¾©è–¬', qty:1}] },
                golem: { id: 'golem', name: 'ã‚°ãƒ©ãƒ³ï¼ã‚´ãƒ¼ãƒ¬ãƒ ', hp: 120, maxHp: 120, atk: 16, def: 6, avoid: 2, exp: 120, drops: [{name:'å¤§ããªé‰±çŸ³', qty:1}] }
              };
            // å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆé€²è¡Œç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
            let currentTextBlocks = [];
            let currentTextIndex = 0;
            let textOverlayEl = null;
            let nextBtnEl = null;

            // å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆã‚’1ã¤ãšã¤typewriterè¡¨ç¤ºã—ã€scene-imageå…¨ä½“ã‚¯ãƒªãƒƒã‚¯ã§æ¬¡ã¸
            function showNextTextBlock(callback) {
              if (!textOverlayEl) textOverlayEl = document.getElementById('scene-text-overlay');
              // â–¼ãƒœã‚¿ãƒ³ã¯æ¯å›æ–°è¦ç”Ÿæˆã—ã€å¼¾å¹•é€ã‚Šã”ã¨ã«appendã™ã‚‹
              nextBtnEl = document.createElement('div');
              nextBtnEl.className = 'scene-text-next';
              nextBtnEl.textContent = 'â–¼';
              nextBtnEl.style.display = 'none';
              nextBtnEl.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
              // ç”»åƒãƒ¬ã‚¤ãƒ¤ãƒ¼å³ä¸‹ã«å¸¸ã«æµ®ã‹ã›ã‚‹ãŸã‚scene-imageç›´ä¸‹ã«append
              const sceneImageDiv2 = document.getElementById('scene-image');
              if (sceneImageDiv2) {
                // æ—¢å­˜ã®nextBtnElã‚’é™¤å»
                const oldNext = sceneImageDiv2.querySelector('.scene-text-next');
                if (oldNext) oldNext.remove();
                sceneImageDiv2.appendChild(nextBtnEl);
              }
              const sceneImageDiv = document.getElementById('scene-image');
              if (sceneImageDiv) {
                sceneImageDiv.classList.add('clickable');
                sceneImageDiv.onclick = () => {
                  if (nextBtnEl.style.display === 'block') {
                    nextBtnEl.style.display = 'none';
                    currentTextIndex++;
                    if (currentTextIndex < currentTextBlocks.length) {
                      showNextTextBlock(callback);
                    } else {
                      sceneImageDiv.onclick = null;
                      sceneImageDiv.classList.remove('clickable');
                      if (callback) callback();
                    }
                  }
                };
              }
              textOverlayEl.innerHTML = '';
              if (currentTextIndex < currentTextBlocks.length) {
                // %ãƒ–ãƒ­ãƒƒã‚¯ã«åˆ°é”ã—ãŸã‚‰é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼
                if (currentTextBlocks[currentTextIndex] === '%') {
                  if (callback) callback();
                  return;
                }
                typeWriterText(textOverlayEl, currentTextBlocks[currentTextIndex], 28, () => {
                  // æœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ãŒå®Œäº†ã—ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€scene6 ã®å ´åˆã¯è‡ªå‹•ã§ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæˆ¦é—˜é–‹å§‹ï¼‰ã™ã‚‹
                  const isLastBlock = (currentTextIndex === currentTextBlocks.length - 1);
                  if (isLastBlock && (window.currentSceneId === 'scene6' || window.currentSceneId === 'scene3B')) {
                    console.log('[showNextTextBlock] final block reached for', window.currentSceneId, '-> showing â–¼ then invoking callback');
                    // è‡ªå‹•æˆ¦é—˜é–‹å§‹ã‚·ãƒ¼ãƒ³ã§ã‚‚ã€ã‚¿ã‚¤ãƒ—å®Œäº†ã‚’æ˜ç¤ºã™ã‚‹ãŸã‚â–¼ã‚’ä¸€ç¬è¡¨ç¤ºã—ã¦ã‹ã‚‰ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹
                    try {
                      nextBtnEl.style.display = 'block';
                      window.__nextShown = true;
                    } catch (e) {}
                    // å°ã•ãªé…å»¶ã‚’ç½®ã„ã¦ç«¶åˆã‚’é¿ã‘ã¤ã¤ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæˆ¦é—˜é–‹å§‹ï¼‰ã‚’å‘¼ã¶
                    setTimeout(() => { if (callback) callback(); }, 140);
                    return;
                  }
                  // â–¼ãŒè¡¨ç¤ºã•ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
                  nextBtnEl.style.display = 'block';
                  window.__nextShown = true;
                  console.log('[showNextTextBlock] next button shown');
                });
              } else {
                // ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã®å ´åˆã§ã‚‚callbackã‚’å‘¼ã¶
                if (callback) callback();
              }
            }
          // Typewriterã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºã—ã€å®Œäº†æ™‚ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
          function typeWriterText(element, html, speed = 28, callback) {
            element.innerHTML = '';
            let i = 0;
            // typing ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
            window.__isTyping = true;
            // HTMLã‚¿ã‚°ã‚’è€ƒæ…®ã—ã¦1æ–‡å­—ãšã¤å‡ºã™
            function type() {
              if (i >= html.length) {
                window.__isTyping = false;
                if (callback) callback();
                return;
              }
              // <br>ãªã©ã®ã‚¿ã‚°ã¯ä¸€æ°—ã«å‡ºã™
              if (html[i] === '<') {
                const close = html.indexOf('>', i);
                if (close !== -1) {
                  element.innerHTML += html.slice(i, close + 1);
                  i = close + 1;
                } else {
                  element.innerHTML += html[i++];
                }
              } else {
                element.innerHTML += html[i++];
              }
              setTimeout(type, speed);
            }
            type();
          }
          // --- é€²è¡Œãƒ»ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ä¿å­˜é››å½¢ ---
        const SAVE_KEY = 'rpg_save';

        function saveGame(state) {
          localStorage.setItem(SAVE_KEY, JSON.stringify(state));
          console.log('ã‚²ãƒ¼ãƒ é€²è¡Œã‚’ä¿å­˜:', state);
        }

        function loadGame() {
          const data = localStorage.getItem(SAVE_KEY);
          if (!data) return null;
          try {
            return JSON.parse(data);
          } catch (e) {
            return null;
          }
        }

        // ä¾‹: ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«é€²è¡ŒçŠ¶æ³ã‚’å¾©å…ƒ
        let gameState = loadGame() || {
          score: 0,
          level: 1,
          hp: 100,
          maxHp: 100,
          exp: 0,
          log: [],
          sceneId: 'start',
          items: []
        };
        // ã‚·ãƒ¼ãƒ³é·ç§»æ™‚ãªã©ã«saveGame(gameState)ã‚’å‘¼ã¶ã“ã¨ã§é€²è¡Œã‚’ä¿å­˜ã§ãã‚‹
    const sceneTitle = document.getElementById('scene-title');
    const sceneImage = document.getElementById('scene-image');
    const choices = document.getElementById('choices');
    const logEl = document.getElementById('log');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const hpEl = document.getElementById('hp');
    const cacheInfo = document.getElementById('cache-info');

    async function fetchScene() {
      const res = await fetch('/api/choose', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });
      
      if (!res.ok) {
        logEl.innerHTML = '<div class="log-entry damage">ã‚·ãƒ¼ãƒ³èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼</div>';
        return;
      }
      
      const data = await res.json();
      console.log('[fetchScene] Response:', data);
      console.log('[fetchScene] image_url:', data.image_url);
      console.log('[fetchScene] image_task_id:', data.image_task_id);
      console.log('[fetchScene] image_key:', data.image_key);
      renderScene(data);
    }

    function renderScene(data) {
      // Title
      sceneTitle.textContent = data.title || '???';
      
      // Image
      if (data.image_url) {
        // normalize leading slash so paths work under repo subpath (GitHub Pages)
        const imgUrl = (data.image_url && data.image_url.startsWith('/')) ? data.image_url.slice(1) : data.image_url;
        console.log('[renderScene] Setting image src to:', imgUrl);
        sceneImage.innerHTML = '<img id="scene-img" src="' + imgUrl + '" alt="Scene" onerror="console.error(\'Image load failed:\', this.src); this.style.border=\'2px solid red\';">';
      } else {
        console.log('[renderScene] No image_url, showing placeholder');
        sceneImage.innerHTML = '<span id="image-placeholder">[ ' + (data.title || 'Scene') + ' ]</span>';
      }

      // If server returned an image generation task id, poll it and update the image when ready
      if (data.image_task_id && data.image_key) {
        pollImageTask(data.image_task_id, data.image_key);
      }
      
      // Stats
      // Use actual HP from server
      if (data.hp !== undefined) {
        gameState.hp = data.hp;
      }
      if (data.max_hp !== undefined) {
        gameState.maxHp = data.max_hp;
      }
      
      // `data.score` may be a number or an object like { total: N, level: L }
      let numericScore = gameState.score;
      if (data.score !== undefined && data.score !== null) {
        if (typeof data.score === 'object') {
          numericScore = Number(data.score.total || data.score.value || numericScore) || numericScore;
        } else {
          numericScore = Number(data.score) || numericScore;
        }
      }
      gameState.score = numericScore;
      // level: prefer provided level if present
      if (data.score && typeof data.score === 'object' && data.score.level) {
        gameState.level = Number(data.score.level) || gameState.level;
      } else {
        gameState.level = Math.max(1, Math.floor(gameState.score / 10) + 1);
      }
      
      scoreEl.textContent = gameState.score;
      levelEl.textContent = gameState.level;
      hpEl.textContent = gameState.hp + '/' + gameState.maxHp;
      
      // Cache badge
      if (data.cache_hit) {
        cacheInfo.style.display = 'inline-block';
      } else {
        cacheInfo.style.display = 'none';
      }
      
      // Log
      if (data.log && data.log.length > 0) {
        logEl.innerHTML = '';
        data.log.slice(-10).forEach(entry => {
          const div = document.createElement('div');
          div.className = 'log-entry';
          if (entry.indexOf('ãƒ€ãƒ¡ãƒ¼ã‚¸') >= 0) {
            div.classList.add('damage');
          } else if (entry.indexOf('å›å¾©') >= 0) {
            div.classList.add('recovery');
          } else if (entry.indexOf('é¸æŠ') >= 0 || entry.indexOf('å®Ÿè¡Œ') >= 0) {
            div.classList.add('action');
          }
          div.textContent = entry;
          logEl.appendChild(div);
        });
      }
      
      // Choicesï¼ˆã“ã“ã§ã¯ä½•ã‚‚å‡ºã•ãªã„ã€‚showSceneã§å¼¾å¹•é€ã‚Šå®Œäº†æ™‚ã®ã¿è¡¨ç¤ºï¼‰
      choices.innerHTML = '';
    }

    // Poll the task status endpoint until ready, then update the scene image src
    function pollImageTask(taskId, imageKey) {
      console.log('[pollImageTask] Starting poll for taskId:', taskId, 'imageKey:', imageKey);
      const attempt = async () => {
        try {
          const res = await fetch('/api/tasks/' + encodeURIComponent(taskId));
          if (!res.ok) {
            console.warn('[pollImageTask] Response not OK:', res.status);
            return;
          }
          const j = await res.json();
          console.log('[pollImageTask] Status:', j);
          if (j.ready) {
            // Replace image src with generated file (cache-bust)
            const img = document.getElementById('scene-img');
            const url = 'media/generated/' + encodeURIComponent(imageKey) + '.png?t=' + Date.now();
            console.log('[pollImageTask] Task ready! Setting image to:', url);
            if (img) {
              img.src = url;
              img.onerror = () => console.error('[pollImageTask] Image load failed:', url);
            } else {
              sceneImage.innerHTML = '<img id="scene-img" src="' + url + '" alt="Scene" onerror="console.error(\'Image load failed:\', this.src)">';
            }
            // show cache badge
            cacheInfo.style.display = 'inline-block';
          } else {
            // try again in 1500ms
            console.log('[pollImageTask] Not ready yet, polling again...');
            setTimeout(attempt, 1500);
          }
        } catch (e) {
          console.error('[pollImageTask] Error:', e);
          setTimeout(attempt, 2000);
        }
      };
      attempt();
    }

    async function selectChoice(choice, idx) {
      console.log('[selectChoice] Selected:', choice);
      
      // Disable all choices while loading
      document.querySelectorAll('.choice-btn').forEach(b => {
        b.disabled = true;
      });
      
      try {
        const res = await fetch('/api/choose', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ choice: choice })
        });
        
        if (!res.ok) {
          console.error('[selectChoice] Error response:', res.status);
          logEl.innerHTML += '<div class="log-entry damage">é¸æŠå‡¦ç†ã‚¨ãƒ©ãƒ¼</div>';
          return;
        }
        
        const data = await res.json();
        console.log('[selectChoice] Response:', data);
        renderScene(data);
      } catch (e) {
        console.error('[selectChoice] Exception:', e);
        logEl.innerHTML += '<div class="log-entry damage">é€šä¿¡ã‚¨ãƒ©ãƒ¼</div>';
      } finally {
        // Re-enable choices
        document.querySelectorAll('.choice-btn').forEach(b => {
          b.disabled = false;
        });
      }
    }

    function openStats() {
      alert('ğŸ“Š ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹\n\nãƒ¬ãƒ™ãƒ«: ' + gameState.level + '\nHP: ' + gameState.hp + '/' + gameState.maxHp + '\nã‚¹ã‚³ã‚¢: ' + gameState.score);
    }

    async function openInventory() {
      try {
        const res = await fetch('/api/inventory', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!res.ok) {
          alert('ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
          return;
        }
        
        const data = await res.json();
        console.log('[openInventory] Data:', data);
        
        let message = 'ğŸ’ æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ \n\n';
        
        if (data.items && Object.keys(data.items).length > 0) {
          for (const [itemName, count] of Object.entries(data.items)) {
            if (count > 0) {
              message += `ãƒ»${itemName} Ã— ${count}\n`;
            }
          }
        } else {
          message += 'ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŒã£ã¦ã„ã¾ã›ã‚“';
        }
        
        if (data.companions && data.companions.length > 0) {
          message += '\n\nâš”ï¸ ä»²é–“:\n';
          data.companions.forEach(comp => {
            message += `ãƒ»${comp.name} (${comp.role})\n`;
          });
        }
        
        alert(message);
      } catch (e) {
        console.error('[openInventory] Error:', e);
        alert('ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      }
    }

    function openMap() {
      alert('ğŸ—º ãƒãƒƒãƒ—\n\n(å®Ÿè£…äºˆå®š)');
    }

    function goBack() {
      if (confirm('å†’é™ºã‚’çµ‚ã‚ã‚Šã¾ã™ã‹ï¼Ÿ')) {
        window.location.href = '/companions/select_page';
      }
    }

    // --- JSONãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿é››å½¢ ---
    async function loadJSON(path) {
      const res = await fetch(path);
      if (!res.ok) throw new Error('ãƒ‡ãƒ¼ã‚¿å–å¾—å¤±æ•—: ' + path);
      return await res.json();
    }

    // ä¾‹: ãƒ‡ãƒ¼ã‚¿ã‚’ã¾ã¨ã‚ã¦èª­ã¿è¾¼ã‚€
    let storyData, charData, itemData;
    Promise.all([
      loadJSON('static/data/story.json'),
      loadJSON('static/data/characters.json'),
      loadJSON('static/data/items.json')
    ]).then(([story, chars, items]) => {
      storyData = story;
      charData = chars;
      itemData = items;
      // ã“ã“ã§ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚„æç”»å‡¦ç†ã‚’å‘¼ã¶
      console.log('ã‚¹ãƒˆãƒ¼ãƒªãƒ¼', storyData);
      console.log('ã‚­ãƒ£ãƒ©', charData);
      console.log('ã‚¢ã‚¤ãƒ†ãƒ ', itemData);
      // èµ·å‹•æ™‚ã¯ã¾ãšã‚·ãƒ¼ãƒ³ã‚’è¡¨ç¤ºã—ã¦ã‹ã‚‰ã€ã‚·ãƒ¼ãƒ³å†…ã§åå‰å…¥åŠ›ã‚’è¡Œã†ï¼ˆä¸–ç•Œè¦³ã‚’ä¿ã¤ï¼‰
      const startGame = () => {
        // prefer a scene with id 'start' if present in storyData
        try {
          const hasStart = story && story.scenes && Array.isArray(story.scenes) && story.scenes.find(s => s.id === 'start');
          if (hasStart) {
            showScene('start');
            return;
          }
        } catch (e) {}
        showScene('scene1');
      };
      // restore saved player name if present
      try {
        const saved = loadGame();
        if (saved && saved.playerName) gameState.playerName = saved.playerName;
      } catch(e) {}
      const storedName = localStorage.getItem('player_name');
      if (!gameState.playerName && storedName) gameState.playerName = storedName;
      // always start scene1 immediately; inline prompt will appear inside scene if needed
      startGame();
    }).catch(e => {
      alert('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + e);
    });

    // ä¸»äººå…¬åå…¥åŠ›ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
    // ç”»é¢å†…ï¼ˆã‚·ãƒ¼ãƒ³ä¸Šï¼‰ã§åå‰ã‚’èãã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å…¥åŠ›ï¼ˆä¸–ç•Œè¦³ã‚’å£Šã•ãªã„ï¼‰
    function showInlineNamePrompt() {
      try {
        // create an overlay similar to choice overlay so it sits above the scene and blocks clicks
        // avoid duplicating if already present
        const existing = document.getElementById('scene-name-overlay');
        if (existing) return;
        const overlay = document.createElement('div');
        overlay.id = 'scene-name-overlay';
        overlay.className = 'scene-choice-overlay';
        overlay.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";

        const inner = document.createElement('div');
        inner.className = 'scene-choice-list';
        inner.style.display = 'flex';
        inner.style.flexDirection = 'column';
        inner.style.alignItems = 'stretch';
        inner.style.background = 'rgba(0,0,0,0.45)';
        inner.style.padding = '12px';
        inner.style.borderRadius = '8px';
        inner.style.maxWidth = '720px';

        const prompt = document.createElement('div');
        prompt.textContent = 'ç›¸æ£’: ã€Œã‚ã®â€¦ã‚ãªãŸã®åå‰ã¯ä½•ã¦ã„ã†ã®ï¼Ÿã€';
        prompt.style.color = '#fff';
        prompt.style.marginBottom = '8px';
        inner.appendChild(prompt);

        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.gap = '8px';

        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'ä¸»äººå…¬ã®åå‰';
        input.className = 'scene-choice-input';
        input.style.flex = '1';
        input.style.padding = '8px';
        input.style.fontSize = '16px';
        row.appendChild(input);

        // Confirm function (Enterã§æ±ºå®š)
        const confirmName = () => {
          const v = (input.value || '').trim() || 'ä¸»äººå…¬';
          gameState.playerName = v;
          saveGame(gameState);
          try { localStorage.setItem('player_name', v); } catch(e){}
          // show small confirmation then remove overlay
          const conf = document.createElement('div');
          inner.appendChild(conf);
          // remove overlay and show the companion's line in the text overlay area
          setTimeout(() => {
            try { overlay.remove(); } catch(e){}
            try {
              // prepare a short companion line in the text overlay (typewriter)
              const companionName = (localStorage.getItem('selected_companion') ? JSON.parse(localStorage.getItem('selected_companion')).name : 'ç›¸æ£’');
              const protagonistName = v;
              const line = `${companionName}ã€Œã‚ˆã‚ã—ãã­ã€${protagonistName}ã€`;
              // set as the only text block and display via typewriter
              currentTextBlocks = [ line.replace(/\n/g, '<br>') ];
              currentTextIndex = 0;
              textOverlayEl = document.getElementById('scene-text-overlay');
              if (textOverlayEl) textOverlayEl.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
              // show the line, then present a single-choice overlay "ã‚ˆã‚ã—ãï¼" which when selected
              // will continue the scene: if the current scene has choices, show them; otherwise do nothing.
              showNextTextBlock(() => {
                try {
                  const scene = (typeof storyData !== 'undefined' && storyData && storyData.scenes) ? storyData.scenes.find(s => s.id === window.currentSceneId) : null;
                  if (scene && scene.choices && scene.choices.length > 0) {
                    showChoicesOverlay(scene.choices, (c) => {
                      if (c.next) {
                        if (typeof c.next === 'string' && c.next.startsWith('battle:')) {
                          const key = c.next.split(':',2)[1];
                          const enemy = ENEMY_DEFS[key] || { id: key, name: key, hp: 40, maxHp: 40, atk: 6, def: 1, avoid: 5 };
                          startBattle(enemy, scene);
                        } else {
                          showScene(c.next);
                        }
                      }
                    });
                  } else {
                    // If the scene has no choices (e.g. start), present a single "ã‚ˆã‚ã—ãï¼" choice
                    showChoicesOverlay([{ text: 'ã‚ˆã‚ã—ãï¼', next: 'AUTO_NEXT' }], (choice) => {
                      if (choice.next === 'AUTO_NEXT') {
                        try {
                          if (storyData && Array.isArray(storyData.scenes)) {
                            const idx = storyData.scenes.findIndex(s => s.id === window.currentSceneId);
                            if (idx !== -1 && idx + 1 < storyData.scenes.length) {
                              showScene(storyData.scenes[idx+1].id);
                            }
                          }
                        } catch(e) { console.error('auto next error', e); }
                      }
                    });
                  }
                } catch(e) { console.error('post-name showNextTextBlock error', e); }
              });
            } catch(e) { console.error('confirmName post-remove error', e); }
          }, 300);
        };
        // Replace explicit button with a small hint
        const hint = document.createElement('div');
        hint.style.color = '#eee';
        hint.style.alignSelf = 'center';
        hint.style.padding = '8px 12px';
        hint.style.fontSize = '13px';
        hint.textContent = 'Enterã‚­ãƒ¼ã§æ±ºå®š';
        row.appendChild(hint);
        inner.appendChild(row);
        overlay.appendChild(inner);

        const sceneImageDiv = document.getElementById('scene-image');
        if (!sceneImageDiv) return;

        // attach only when ready (no typing & no next visible), like choices
        function attachOverlayWhenReady() {
          function readyToAttach() {
            const nextBtn = document.querySelector('.scene-text-next');
            const nextVisible = nextBtn && nextBtn.style && nextBtn.style.display === 'block';
            return !window.__isTyping && !nextVisible;
          }
          if (readyToAttach()) {
            setTimeout(() => { if (readyToAttach()) {
              // remove only the underlying "åå‰ã‚’æ•™ãˆã‚‹" choice button if present
              try {
                const existingChoiceOverlay = sceneImageDiv.querySelector('#scene-choice-overlay');
                if (existingChoiceOverlay) {
                  existingChoiceOverlay.querySelectorAll('.scene-choice-btn').forEach(btn => {
                    try { if (btn.textContent && btn.textContent.trim() === 'åå‰ã‚’æ•™ãˆã‚‹') btn.remove(); } catch(e){}
                  });
                  if (existingChoiceOverlay.querySelectorAll('.scene-choice-btn').length === 0) existingChoiceOverlay.remove();
                }
              } catch(e){}
              // ensure overlay captures clicks and prevents scene-image click-through
              try { sceneImageDiv._prevOnclick = sceneImageDiv.onclick; } catch(e){}
              sceneImageDiv.appendChild(overlay);
              sceneImageDiv.classList.remove('clickable');
              sceneImageDiv.onclick = null;
            } }, 140);
            return;
          }
          const iv = setInterval(() => {
            if (readyToAttach()) {
              clearInterval(iv);
              setTimeout(() => { if (readyToAttach()) {
                // remove only the underlying "åå‰ã‚’æ•™ãˆã‚‹" choice button if present
                try {
                  const existingChoiceOverlay = sceneImageDiv.querySelector('#scene-choice-overlay');
                  if (existingChoiceOverlay) {
                    existingChoiceOverlay.querySelectorAll('.scene-choice-btn').forEach(btn => {
                      try { if (btn.textContent && btn.textContent.trim() === 'åå‰ã‚’æ•™ãˆã‚‹') btn.remove(); } catch(e){}
                    });
                    if (existingChoiceOverlay.querySelectorAll('.scene-choice-btn').length === 0) existingChoiceOverlay.remove();
                  }
                } catch(e){}
                try { sceneImageDiv._prevOnclick = sceneImageDiv.onclick; } catch(e){}
                sceneImageDiv.appendChild(overlay);
                sceneImageDiv.classList.remove('clickable');
                sceneImageDiv.onclick = null;
              } }, 140);
            }
          }, 50);
        }
        attachOverlayWhenReady();

        // prevent clicks inside overlay from bubbling to sceneImageDiv
        overlay.addEventListener('click', (e) => { e.stopPropagation(); });
        input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); confirmName(); } });
      } catch (e) { console.error('showInlineNamePrompt error', e); }
    }

    // ã‚·ãƒ¼ãƒ³è¡¨ç¤ºã®é››å½¢
    function showScene(sceneId) {
        currentTextBlocks = [];
        currentTextIndex = 0;
      // --- ã‚·ãƒ¼ãƒ³é€²è¡Œæ™‚ã«UIé‡è¤‡ã‚’é˜²ããŸã‚ã€scene-imageé…ä¸‹ã®ä¸è¦ãªè¦ç´ ã‚’æ¯å›ã‚¯ãƒªã‚¢ ---
      const sceneImageDiv = document.getElementById('scene-image');
      if (sceneImageDiv) {
        // ã‚·ãƒ¼ãƒ³é€²è¡Œæ™‚ã€scene-imageé…ä¸‹ã‚’å®Œå…¨ã‚¯ãƒªã‚¢ï¼ˆå…¨UIç«¶åˆé˜²æ­¢ï¼‰
        sceneImageDiv.innerHTML = '';
        // ç”»åƒè¦ç´ ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’å†ç”Ÿæˆ
        const img = document.createElement('img');
        img.id = 'scene-img';
        img.src = '';
        img.alt = 'scene';
        img.style.maxWidth = '100%';
        img.style.maxHeight = '100%';
        img.style.borderRadius = '2px';
        img.style.display = 'none';
        sceneImageDiv.appendChild(img);
        const placeholder = document.createElement('span');
        placeholder.id = 'image-placeholder';
        placeholder.textContent = 'ç”»åƒæº–å‚™ä¸­...';
        sceneImageDiv.appendChild(placeholder);
        const textOverlay = document.createElement('div');
        textOverlay.className = 'scene-text-overlay';
        textOverlay.id = 'scene-text-overlay';
        textOverlay.style.display = 'block';
        sceneImageDiv.appendChild(textOverlay);
      }
      // ãƒ‡ãƒãƒƒã‚°: å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆã¨è¦ç´ ã®çŠ¶æ…‹ã‚’å‡ºåŠ›
      console.log('[å¼¾å¹•ãƒ‡ãƒãƒƒã‚°] sceneId:', sceneId);
      // ãƒ‡ãƒãƒƒã‚°ç”¨: ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³IDã¨å…¨ã‚·ãƒ¼ãƒ³IDä¸€è¦§ã‚’å‡ºåŠ›
      console.log("currentSceneId:", sceneId);
      if (storyData && storyData.scenes) {
        console.log("scenes ids:", storyData.scenes.map(s => s.id));
      } else {
        console.log("storyDataã¾ãŸã¯scenesãŒæœªå®šç¾©");
      }
      const scene = storyData.scenes.find(s => s.id === sceneId);
      // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ãƒ¼ãƒ³IDã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¿æŒï¼ˆå¼¾å¹•å®Œäº†æ™‚ã®è‡ªå‹•å‡¦ç†åˆ¤å®šç”¨ï¼‰
      window.currentSceneId = sceneId;
      if (!scene) {
        alert('ã‚·ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + sceneId);
        return;
      }
      // ä»¥å‰ã¯ scene3B ã§å³æ™‚æˆ¦é—˜é–‹å§‹ã—ã¦ã„ãŸãŒã€å¼¾å¹•ï¼ˆã‚»ãƒªãƒ•ï¼‰å®Œäº†å¾Œã«é–‹å§‹ã™ã‚‹ã‚ˆã†å¤‰æ›´
      if (currentTextBlocks.length > 0) {
        showNextTextBlock(() => {
          // å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆã‚’ã™ã¹ã¦å‡ºåŠ›ã—ãã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
          console.log('[å¼¾å¹•å®Œäº†] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'currentTextIndex:', currentTextIndex, 'currentTextBlocks:', currentTextBlocks);
          if (scene.choices && Array.isArray(scene.choices) && scene.choices.length > 0) {
            console.log('[é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'choices:', scene.choices);
            showChoicesOverlay(scene.choices, (choice) => {
              // é¸æŠè‚¢ã‚¯ãƒªãƒƒã‚¯æ™‚ã€'battle:KEY' ãªã‚‰æˆ¦é—˜é–‹å§‹ã€ãã†ã§ãªã‘ã‚Œã°æ¬¡ã®ã‚·ãƒ¼ãƒ³ã¸
              if (choice.next) {
                if (typeof choice.next === 'string' && choice.next.startsWith('battle:')) {
                  const key = choice.next.split(':',2)[1];
                  const enemy = ENEMY_DEFS[key] || { id: key, name: key, hp: 40, maxHp: 40, atk: 6, def: 1, avoid: 5 };
                  startBattle(enemy, scene);
                } else {
                  showScene(choice.next);
                }
              }
            });
          } else {
            console.log('[é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'â†’ é¸æŠè‚¢ãªã—');
          }
        });
      } else if (scene.choices && Array.isArray(scene.choices) && scene.choices.length > 0) {
        // ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ã‚‚é¸æŠè‚¢ãŒã‚ã‚Œã°ãƒ€ãƒŸãƒ¼å¼¾å¹•é€ã‚Šã‚’1å›ç™ºç”Ÿã•ã›ã¦ã‚¯ãƒªãƒƒã‚¯å¾Œã«é¸æŠè‚¢ã‚’è¡¨ç¤º
        currentTextBlocks = [''];
        currentTextIndex = 0;
        showNextTextBlock(() => {
          console.log('[å¼¾å¹•å®Œäº†:ãƒ€ãƒŸãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'currentTextIndex:', currentTextIndex, 'currentTextBlocks:', currentTextBlocks);
          console.log('[é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'choices:', scene.choices);
          showChoicesOverlay(scene.choices, (choice) => {
            if (choice.next) {
              if (typeof choice.next === 'string' && choice.next.startsWith('battle:')) {
                const key = choice.next.split(':',2)[1];
                const enemy = ENEMY_DEFS[key] || { id: key, name: key, hp: 40, maxHp: 40, atk: 6, def: 1, avoid: 5 };
                startBattle(enemy, scene);
              } else {
                showScene(choice.next);
              }
            }
          });
        });
      } else {
        // ãƒ†ã‚­ã‚¹ãƒˆã‚‚é¸æŠè‚¢ã‚‚ãªã„å ´åˆ
        console.log('[å¼¾å¹•ã‚¹ã‚­ãƒƒãƒ—] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'currentTextBlocksãŒç©ºãƒ»é¸æŠè‚¢ã‚‚ãªã—');
      }
      // ç›¸æ£’åãƒ»å½¹è·ã‚’localStorageã‹ã‚‰å–å¾—
      let companionName = 'ãƒªã‚£ãƒŠ';
      let companionRole = 'priest';
      try {
        const sel = localStorage.getItem('selected_companion');
        if (sel) {
          const obj = JSON.parse(sel);
          if (obj && obj.name) companionName = obj.name;
          if (obj && obj.role) companionRole = obj.role;
        }
      } catch(e) {}
      // ã‚¿ã‚¤ãƒˆãƒ«
      document.getElementById('scene-title').textContent = (scene.title || 'æ—…è·¯ã®å§‹ã¾ã‚Š');
      // æœ¬æ–‡ï¼ˆ${companion_name}ã‚’ç½®æ›ï¼‰
      let text = scene.text || '';
      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      text = text.replace(/\$\{companion_name\}/g, companionName).replace(/\$\{companion_role\}/g, companionRole);
      // %ãƒˆãƒªã‚¬ãƒ¼å¯¾å¿œ: %ãŒã‚ã‚Œã°ãã“ã¾ã§å¼¾å¹•é€ã‚Šã€%ã§é¸æŠè‚¢è¡¨ç¤ºã€‚ãªã‘ã‚Œã°å¾“æ¥é€šã‚Šã€‚
      let rawBlocks = text.split(/\n\n/).map(s => s.trim());
      let triggerIndex = rawBlocks.findIndex(b => b === '%');
      if (triggerIndex !== -1) {
        // %ãŒã‚ã‚Œã°ãã“ã¾ã§ã‚’å¼¾å¹•é€ã‚Šã€%ã§é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼
        currentTextBlocks = rawBlocks.slice(0, triggerIndex).map(s => s.replace(/\n/g, '<br>')).filter(s => s.length > 0);
        currentTextBlocks.push('%'); // ãƒˆãƒªã‚¬ãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ˜ç¤ºçš„ã«å…¥ã‚Œã‚‹
      } else {
        // %ãŒãªã‘ã‚Œã°å¾“æ¥é€šã‚Š
        currentTextBlocks = rawBlocks.map(s => s.replace(/\n/g, '<br>')).filter(s => s.length > 0);
      }
      currentTextIndex = 0;
      textOverlayEl = document.getElementById('scene-text-overlay');
      if (textOverlayEl) textOverlayEl.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
      showNextTextBlock(() => {
        // %ãƒˆãƒªã‚¬ãƒ¼ã¾ãŸã¯å¼¾å¹•å®Œäº†æ™‚ã«é¸æŠè‚¢ã€ã¾ãŸã¯ç‰¹å®šã‚·ãƒ¼ãƒ³ã§æˆ¦é—˜é–‹å§‹
        const atTextEnd = (
          (currentTextBlocks.length > 0 && currentTextBlocks[currentTextBlocks.length - 1] === '%' && currentTextIndex === currentTextBlocks.length - 1)
          || (currentTextBlocks.length > 0 && currentTextBlocks[currentTextBlocks.length - 1] !== '%' && currentTextIndex === currentTextBlocks.length)
        );
        if (atTextEnd) {
          // scene6ã¯å¼¾å¹•ï¼ˆã‚»ãƒªãƒ•ï¼‰ãŒçµ‚ã‚ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚´ãƒ¼ãƒ¬ãƒ æˆ¦ã‚’é–‹å§‹
          if (scene.id === 'scene6') {
            const enemy = { id: 'golem', name: 'ã‚°ãƒ©ãƒ³ï¼ã‚´ãƒ¼ãƒ¬ãƒ ', hp: 120, maxHp: 120, atk: 16, def: 6, avoid: 2 };
            startBattle(enemy, scene);
            return;
          }
          if (scene.choices && Array.isArray(scene.choices) && scene.choices.length > 0) {
            showChoicesOverlay(scene.choices, (choice) => {
              if (choice.next) {
                if (typeof choice.next === 'string' && choice.next.startsWith('battle:')) {
                  const key = choice.next.split(':',2)[1];
                  const enemy = ENEMY_DEFS[key] || { id: key, name: key, hp: 40, maxHp: 40, atk: 6, def: 1, avoid: 5 };
                  startBattle(enemy, scene);
                } else {
                  showScene(choice.next);
                }
              }
            });
          }
        }
      });
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã«è¨˜éŒ²
      const logEl = document.getElementById('log');
      if (logEl) {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
        // ç™ºè¨€è€…åã®æŠ½å‡ºï¼ˆã€Œã‚­ãƒ£ãƒ©åã€Œã€ã€ã‚„${companion_name}ãªã©ï¼‰
        let logText = text.replace(/<br>/g, ' ');
        // XSSå¯¾ç­–ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        function escapeHtml(str) {
          return str.replace(/[&<>"']/g, function(tag) {
            const chars = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'};
            return chars[tag] || tag;
          });
        }
        // \nã‚’æ”¹è¡Œã¨ã—ã¦åæ˜ 
        entry.innerHTML = escapeHtml(logText).replace(/\n/g, '<br>');
        logEl.appendChild(entry);
        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸€ç•ªä¸‹ã¸
        logEl.scrollTop = logEl.scrollHeight;
      }
      // ç”»åƒ
      const sceneImg = document.getElementById('scene-img');
      const imagePlaceholder = document.getElementById('image-placeholder');
      if (scene.image) {
        let imgPath = scene.image;
        imgPath = imgPath.replace(/\$\{companion_role\}/g, companionRole);
        let absPath = '';
        if (imgPath.startsWith('pregenerated/')) {
          absPath = 'media/pregenerated/' + imgPath.substring('pregenerated/'.length);
        } else if (imgPath.startsWith('/')) {
          absPath = imgPath;
        } else {
          absPath = 'media/characters/' + imgPath;
        }
        console.log("ç”»åƒãƒ‘ã‚¹:", absPath);
        sceneImg.src = absPath;
        sceneImg.style.display = '';
        sceneImg.onerror = function() {
          this.style.display = 'none';
          if (imagePlaceholder) imagePlaceholder.textContent = 'ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
        };
        if (imagePlaceholder) imagePlaceholder.style.display = 'none';
      } else {
        sceneImg.style.display = 'none';
        if (imagePlaceholder) {
          imagePlaceholder.textContent = 'ç”»åƒãªã—';
          imagePlaceholder.style.display = '';
        }
      }
      console.log('ã‚·ãƒ¼ãƒ³è¡¨ç¤º:', scene);
      // ã‚·ãƒ¼ãƒ³1åˆ°é”æ™‚ã€ã¾ã ä¸»äººå…¬åãŒæœªè¨­å®šãªã‚‰ã‚¤ãƒ³ãƒ¯ãƒ¼ãƒ«ãƒ‰ãªå…¥åŠ›æ¬„ã‚’è¡¨ç¤ºã—ã¦å–å¾—ã™ã‚‹
      try {
        // ä½“é¨“ç‰ˆä»•æ§˜: å¸¸ã«èµ·å‹•æ™‚ã«ã‚¤ãƒ³ãƒ¯ãƒ¼ãƒ«ãƒ‰ã§åå‰ã‚’èãï¼ˆä¿å­˜ãŒã‚ã£ã¦ã‚‚æ¯å›ï¼‰
          if (sceneId === 'start') {
            setTimeout(() => { showInlineNamePrompt(); }, 120);
          }
      } catch (e) {}
    }

    // --- æˆ¦é—˜ãƒ­ã‚¸ãƒƒã‚¯ ---
    let battleState = null;

    function startBattle(enemy, sceneContext) {
      if (!battleState) battleState = {};
      // äºŒé‡èµ·å‹•é˜²æ­¢ãƒ•ãƒ©ã‚°
      if (battleState._started) return;
      battleState._started = true;
      battleState.enemy = Object.assign({}, enemy);
      // å…¥å ´æ™‚ã«æ®‹ã£ã¦ã„ã‚‹UIã‚’å®Œå…¨ã«æ¶ˆã™ï¼ˆæ®‹ã£ãŸâ–¼ã‚„é¸æŠè‚¢ãªã©ï¼‰
      try {
        // remove any next arrows
        document.querySelectorAll('.scene-text-next').forEach(n => n.remove());
        // remove choice overlay if any
        const co = document.getElementById('scene-choice-overlay'); if (co) co.remove();
        // clear scene-image click
        const sid = document.getElementById('scene-image'); if (sid) { sid.classList.remove('clickable'); sid.onclick = null; }
        window.__nextShown = false;
      } catch (e) { console.warn('startBattle cleanup error', e); }
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ä¸»äººå…¬ + ç›¸æ£’ã€‚ç›¸æ£’ã®atkã®2å€ãŒä¸»äººå…¬ã®atk
      const sel = localStorage.getItem('selected_companion');
      const companionName = sel ? JSON.parse(sel).name : 'ç›¸æ£’';
      // åŸºæœ¬å€¤ï¼ˆèª¿æ•´å¯ï¼‰
      const companionDefault = { hp: 40, maxHp: 40, atk: 8, def: 2, avoid: 6 };
      battleState.companion = Object.assign({}, companionDefault, { name: companionName });
      battleState.protagonist = {
        name: (gameState && gameState.playerName) ? gameState.playerName : 'ä¸»äººå…¬',
        hp: gameState.hp || 100,
        maxHp: gameState.maxHp || 100,
        atk: (battleState.companion.atk || companionDefault.atk) * 2,
        def: 3,
        avoid: 6
      };
      // convenience alias for older code paths
      battleState.player = battleState.protagonist;
      battleState.turn = 'player';
      // å›å¾©åˆ¶é™: ä½“é¨“ç‰ˆã§ã¯å›å¾©ã¯æœ€å¤§3å›ã¾ã§
      battleState.healsUsed = 0;
      battleState.healLimit = 3;
      renderBattleUI(sceneContext);
    }

    // --- å ±é…¬ãƒ»çµŒé¨“å‡¦ç† ---
    function awardRewards(enemy, resultElem) {
      const exp = (enemy && enemy.exp) ? enemy.exp : 20;
      const drops = (enemy && enemy.drops) ? enemy.drops : [];
      // ã‚¢ã‚¤ãƒ†ãƒ ç²å¾—ï¼ˆç°¡æ˜“ï¼‰
      if (!gameState.items) gameState.items = [];
      const dropText = drops.map(d => {
        // add to inventory (simplified: push name multiple times)
        for (let i=0;i<(d.qty||1);i++) gameState.items.push(d.name);
        return d.qty ? `${d.name} x${d.qty}` : d.name;
      }).join(', ') || 'ãªã—';
      // çµŒé¨“ä»˜ä¸
      gameState.exp = (gameState.exp || 0) + exp;
      saveGame(gameState);
      // è¡¨ç¤º
      if (resultElem) {
        const info = document.createElement('div');
        info.className = 'battle-result-info';
        info.style.fontSize = '16px';
        info.style.marginTop = '8px';
        info.textContent = `ç²å¾—: ${dropText}ã€€çµŒé¨“ +${exp}`;
        resultElem.appendChild(info);
      }
      // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—åˆ¤å®š
      checkLevelUp(resultElem);
    }

    function checkLevelUp(resultElem) {
      // ç°¡æ˜“: ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤ã¯ level * 100
      if (!gameState) return;
      let leveled = false;
      while ((gameState.exp || 0) >= (gameState.level * 100)) {
        gameState.exp -= gameState.level * 100;
        gameState.level = (gameState.level || 1) + 1;
        // HPå¢—åŠ ãªã©
        gameState.maxHp = (gameState.maxHp || 100) + 10;
        gameState.hp = Math.min(gameState.maxHp, (gameState.hp || gameState.maxHp));
        leveled = true;
      }
      if (leveled) {
        saveGame(gameState);
        appendLog(`ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ç¾åœ¨ãƒ¬ãƒ™ãƒ«: ${gameState.level}`);
        if (resultElem) {
          const lv = document.createElement('div');
          lv.className = 'battle-result-levelup';
          lv.style.fontSize = '18px';
          lv.style.marginTop = '6px';
          lv.style.fontWeight = '800';
          lv.textContent = `ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ ç¾åœ¨ãƒ¬ãƒ™ãƒ« ${gameState.level}`;
          resultElem.appendChild(lv);
        }
      }
    }

    function renderBattleUI(sceneContext) {
      const sceneImageDiv = document.getElementById('scene-image');
      const sceneImg = document.getElementById('scene-img');
      const imagePlaceholder = document.getElementById('image-placeholder');
      // ç”»åƒã‚’æˆ¦é—˜ç”¨ã«åˆ‡ã‚Šæ›¿ãˆã€‚sceneContext.image ãŒã‚ã‚Œã°ãã‚Œã‚’å„ªå…ˆã—ã¦è¡¨ç¤ºã™ã‚‹
      if (sceneImg) {
        try {
          let imgPath = (sceneContext && sceneContext.image) ? sceneContext.image : 'pregenerated/scene3-battle.jpg';
          if (imgPath.startsWith('pregenerated/')) {
            imgPath = 'media/pregenerated/' + imgPath.substring('pregenerated/'.length);
          } else if (imgPath.startsWith('/')) {
            // keep absolute if provided (but typically we use repo-relative)
            imgPath = imgPath.slice(1);
          } else if (!imgPath.startsWith('media/')) {
            imgPath = 'media/characters/' + imgPath;
          }
          sceneImg.src = imgPath;
          sceneImg.style.display = '';
        } catch (e) {
          console.error('renderBattleUI image set error', e);
        }
      }
      if (imagePlaceholder) imagePlaceholder.style.display = 'none';

      // å¼¾å¹•ï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼‰ã‚’éè¡¨ç¤ºã«ã—ã¦ã€ãã®é ˜åŸŸã«æˆ¦é—˜ã‚³ãƒãƒ³ãƒ‰ã‚’ç½®ã
      const textOverlay = document.getElementById('scene-text-overlay');
      if (textOverlay) {
        textOverlay.innerHTML = '';
        // æˆ¦é—˜ä¸­ãƒ•ãƒ©ã‚°ç”¨ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ ï¼ˆèƒŒæ™¯ã‚’è»½ãã™ã‚‹ãŸã‚ï¼‰
        textOverlay.classList.add('in-battle');
        textOverlay.style.pointerEvents = 'auto';
        textOverlay.style.display = 'block';
      }

      // ã‚‚ã—â–¼ï¼ˆscene-text-nextï¼‰ãŒæ®‹ã£ã¦ã„ã‚Œã°ç¢ºå®Ÿã«å‰Šé™¤ã—ã¦ãŠã
      try {
        const oldNext = sceneImageDiv.querySelector('.scene-text-next');
        if (oldNext) oldNext.remove();
        sceneImageDiv.classList.remove('clickable');
        sceneImageDiv.onclick = null;
      } catch (e) {}

      // è¡¨ç¤ºã¯æ•µåã®ã¿ï¼ˆä¸­å¤®ï¼‰
      // ç”»åƒä¸­å¤®ã«æ•µåã‚’è¡¨ç¤º (ä¸Šã§å–å¾—ã—ãŸ `sceneImageDiv` ã‚’åˆ©ç”¨)
      // remove existing center name
      const oldCenter = sceneImageDiv.querySelector('.battle-center-name');
      if (oldCenter) oldCenter.remove();
      const centerName = document.createElement('div');
      centerName.className = 'battle-center-name';
      centerName.textContent = battleState.enemy.name;
      sceneImageDiv.appendChild(centerName);

      // actions: ç”»åƒä¸Šã«ç‹¬ç«‹ã•ã›ã‚‹ãƒ‘ãƒãƒ«ã¨ã—ã¦é…ç½®ï¼ˆå¼¾å¹•ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã¯åˆ†é›¢ï¼‰
      let actionsPanel = sceneImageDiv.querySelector('.battle-actions-panel');
      if (actionsPanel) actionsPanel.remove();
      actionsPanel = document.createElement('div');
      actionsPanel.className = 'battle-actions-panel';
      actionsPanel.style.pointerEvents = 'auto';
      const btnAttack = document.createElement('button'); btnAttack.className='battle-action-btn'; btnAttack.textContent='æ”»æ’ƒ'; btnAttack.onclick = () => playerAction('attack');
      const btnDefend = document.createElement('button'); btnDefend.className='battle-action-btn'; btnDefend.textContent='é˜²å¾¡'; btnDefend.onclick = () => playerAction('defend');
      const btnDodge = document.createElement('button'); btnDodge.className='battle-action-btn'; btnDodge.textContent='å›é¿'; btnDodge.onclick = () => playerAction('dodge');
      const btnItem = document.createElement('button'); btnItem.className='battle-action-btn'; btnItem.textContent='ã‚¢ã‚¤ãƒ†ãƒ '; btnItem.onclick = () => playerAction('item');
      actionsPanel.appendChild(btnAttack); actionsPanel.appendChild(btnDefend); actionsPanel.appendChild(btnDodge); actionsPanel.appendChild(btnItem);
      sceneImageDiv.appendChild(actionsPanel);

      // battle display (å¼¾å¹•è¡¨ç¤ºç”¨): æ¯å›ä¸Šæ›¸ãã—ã¦è¡¨ç¤ºã™ã‚‹é ˜åŸŸ
      let battleDisplay = textOverlay.querySelector('.battle-display');
      if (!battleDisplay) {
        battleDisplay = document.createElement('div');
        battleDisplay.className = 'battle-display';
        battleDisplay.style.minHeight = '48px';
        battleDisplay.style.marginBottom = '1px';
        textOverlay.appendChild(battleDisplay);
      }

      // battle log area (å±¥æ­´): è¡¨ç¤ºã¯æ®‹ã™ãŒä»¶æ•°ã‚’åˆ¶é™
      let log = textOverlay.querySelector('.battle-log');
      if (!log) {
        log = document.createElement('div');
        log.className = 'battle-log';
        log.id = 'battle-log';
        textOverlay.appendChild(log);
      }
      // DOMãŒå®‰å®šã™ã‚‹ã¾ã§å°‘ã—é…å»¶ã—ã¦ãƒ­ã‚°å‡ºåŠ›é–‹å§‹ï¼ˆå…ˆé ­ãƒ­ã‚°ã®è¡¨ç¤ºæ¼ã‚Œå¯¾ç­–ï¼‰
      setTimeout(() => appendBattleLog('æˆ¦é—˜é–‹å§‹ï¼æ•µãŒç¾ã‚ŒãŸï¼š' + battleState.enemy.name), 80);
      battleState.turn = 'player';
      updateBattleUI();
    }

    function appendBattleLog(msg) {
      const textOverlay = document.getElementById('scene-text-overlay');
      const log = document.getElementById('battle-log') || (textOverlay && textOverlay.querySelector('.battle-log'));
      const battleDisplay = (textOverlay && textOverlay.querySelector('.battle-display')) || document.querySelector('.battle-display');
      if (!log && !battleDisplay) return;
      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã‚’ç”¨æ„
      if (!battleState) {
        console.warn('[appendBattleLog] called but no battleState; ignoring:', msg);
        return;
      }
      if (!Array.isArray(battleState._queue)) battleState._queue = [];
      battleState._queue.push(msg);
      // éåŒæœŸã§1ã¤ãšã¤å‡¦ç†ã™ã‚‹
      if (battleState._processing) return;
      battleState._processing = true;
      const processNext = () => {
        // guard: battleState may have been cleared while async callbacks were pending
        if (!battleState) {
          // nothing to do
          return;
        }
        if (!battleState._queue || battleState._queue.length === 0) {
          battleState._processing = false;
          return;
        }
        const nextMsg = battleState._queue.shift();
        // flush previous pending into history before typing next (guard if battle ended)
        if (battleState && battleState._pendingLogs && log) {
          battleState._pendingLogs.forEach(m => {
            const d = document.createElement('div'); d.textContent = m;
            log.appendChild(d);
          });
          while (log.children.length > 3) log.removeChild(log.children[0]);
          log.scrollTop = log.scrollHeight;
          battleState._pendingLogs = [];
        }
        // show in battleDisplay then push to pending
        typeWriterText(battleDisplay, (''+nextMsg).replace(/[&<>"]/g, function(ch){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'})[ch] || ch; }), 20, () => {
          // If battleState no longer exists (battle ended/cleaned up), skip adding pending logs
          if (!battleState) {
            // continue processing queue if any (but don't recreate battleState)
            setTimeout(processNext, 120);
            return;
          }
          if (!battleState._pendingLogs) battleState._pendingLogs = [];
          battleState._pendingLogs.push(nextMsg);
          while (battleState._pendingLogs.length > 3) battleState._pendingLogs.shift();
          // å°ã•ãªé…å»¶ã®å¾Œã€æ¬¡ã‚’å‡¦ç†
          setTimeout(processNext, 120);
        });
      };
      processNext();
      return;
      // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
      function escapeHtml(str) {
        return (''+str).replace(/[&<>\"]/g, function(ch){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'})[ch] || ch; });
      }
      // å¼¾å¹•è¡¨ç¤ºï¼ˆä¸Šæ›¸ãã§1è¡Œãšã¤è¡¨ç¤ºï¼‰: è¡¨ç¤ºä¸­ã®è¡Œã¯å±¥æ­´ã«å³è¿½åŠ ã›ãšã€æ¬¡ã®è¡ŒãŒæ¥ãŸã¨ãã«å‰ã®è¡Œã‚’å±¥æ­´ã¸ç§»ã™æ–¹å¼
      if (battleDisplay) {
        // initialize pending buffer on battleState
        if (!battleState) battleState = {};
        if (!battleState._pendingLogs) battleState._pendingLogs = [];
        // flush pending logs into visible history before showing the next message
        if (battleState._pendingLogs.length > 0 && log) {
          battleState._pendingLogs.forEach(m => {
            const d = document.createElement('div'); d.textContent = m;
            log.appendChild(d);
          });
          while (log.children.length > 3) log.removeChild(log.children[0]);
          log.scrollTop = log.scrollHeight;
          battleState._pendingLogs = [];
        }
        // show current message in battleDisplay, then store it as pending (not immediately in history)
        typeWriterText(battleDisplay, escapeHtml(msg), 20, () => {
          battleState._pendingLogs.push(msg);
          // keep pending buffer small
          while (battleState._pendingLogs.length > 3) battleState._pendingLogs.shift();
        });
      } else {
        // battleDisplay ãŒãªã„å ´åˆã¯é€šå¸¸ã®å±¥æ­´è¿½åŠ 
        const d = document.createElement('div'); d.textContent = msg;
        log.appendChild(d);
        while (log.children.length > 3) log.removeChild(log.children[0]);
        log.scrollTop = log.scrollHeight;
      }
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã¸è¿½è¨˜ (ãƒ¡ã‚¤ãƒ³ç”»é¢ç”¨)
    function appendLog(msg) {
      const logElMain = document.getElementById('log');
      if (!logElMain) return;
      const div = document.createElement('div');
      div.className = 'log-entry action';
      div.textContent = msg;
      logElMain.appendChild(div);
      logElMain.scrollTop = logElMain.scrollHeight;
    }

    function updateBattleUI() {
      const textOverlay = document.getElementById('scene-text-overlay');
      if (!textOverlay) return;
      const enemyFill = textOverlay.querySelector('.hp-fill[data-role="enemy"]');
      const protFill = textOverlay.querySelector('.hp-fill[data-role="protagonist"]');
      const compFill = textOverlay.querySelector('.hp-fill[data-role="companion"]');
      if (enemyFill) enemyFill.style.width = Math.max(0,Math.round((battleState.enemy.hp/battleState.enemy.maxHp)*100)) + '%';
      if (protFill) protFill.style.width = Math.max(0,Math.round((battleState.protagonist.hp/battleState.protagonist.maxHp)*100)) + '%';
      if (compFill) compFill.style.width = Math.max(0,Math.round((battleState.companion.hp/battleState.companion.maxHp)*100)) + '%';
      // disable actions if not player's turn (actions panel is attached to scene-image)
      const sceneImageDiv = document.getElementById('scene-image');
      if (sceneImageDiv) {
        sceneImageDiv.querySelectorAll('.battle-action-btn').forEach(b => b.disabled = (battleState.turn !== 'player'));
        // disable item button if heal limit reached
        try {
          const itemBtn = sceneImageDiv.querySelector('.battle-action-btn:nth-child(4)');
          if (itemBtn) {
            const limit = (battleState && battleState.healLimit) || 3;
            const used = (battleState && battleState.healsUsed) || 0;
            itemBtn.disabled = itemBtn.disabled || (used >= limit);
          }
        } catch (e) {}
      }
    }

    function playerAction(action) {
      if (!battleState || battleState.turn !== 'player') return;
      switch(action) {
        case 'attack': {
          // ä¸»äººå…¬æ”»æ’ƒ
          const p = battleState.protagonist;
          const e = battleState.enemy;
          const dmg1 = Math.max(1, p.atk - (e.def || 0));
            e.hp -= dmg1;
            console.log('[playerAction] protagonist dealt', dmg1, 'to', e.name, 'new hp=', e.hp);
            appendBattleLog(`${p.name}ã®æ”»æ’ƒï¼${e.name}ã«${dmg1}ãƒ€ãƒ¡ãƒ¼ã‚¸`);
            if (e.hp <= 0) {
              console.log('[playerAction] enemy hp <=0, triggering endBattle(true) for', e.name);
              appendBattleLog(`${e.name} ã‚’å€’ã—ãŸï¼`);
              endBattle(true);
              return;
            }
          // ç›¸æ£’æ”»æ’ƒ
          const c = battleState.companion;
          const dmg2 = Math.max(1, c.atk - (e.def || 0));
            e.hp -= dmg2;
            console.log('[playerAction] companion dealt', dmg2, 'to', e.name, 'new hp=', e.hp);
            appendBattleLog(`${c.name}ã®è¿½æ’ƒï¼${e.name}ã«${dmg2}ãƒ€ãƒ¡ãƒ¼ã‚¸`);
            if (e.hp <= 0) {
              console.log('[playerAction] enemy hp <=0 after companion, triggering endBattle(true) for', e.name);
              appendBattleLog(`${e.name} ã‚’å€’ã—ãŸï¼`);
              endBattle(true);
              return;
            }
          break;
        }
        case 'defend': {
          battleState.player.def += 2;
          appendBattleLog(`${battleState.player.name}ã¯é˜²å¾¡ã®æ§‹ãˆã€‚æ¬¡ã®è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è»½æ¸›ã—ã¾ã™ã€‚`);
          // ç›¸æ£’ãŒä»£ã‚ã‚Šã«æ”»æ’ƒ
          const c = battleState.companion;
          const e = battleState.enemy;
          if (c && e && e.hp > 0) {
            const dmg = Math.max(1, c.atk - (e.def || 0));
            e.hp -= dmg;
            appendBattleLog(`${c.name}ã®æ´è­·æ”»æ’ƒï¼${e.name}ã«${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸`);
            if (e.hp <= 0) {
              appendBattleLog(`${e.name} ã‚’å€’ã—ãŸï¼`);
              endBattle(true);
              return;
            }
          }
          break;
        }
        case 'dodge': {
          // å›é¿ã¯æˆåŠŸç‡ã§å‡¦ç†
          const success = Math.random()*100 < 30 + (battleState.player.avoid - battleState.enemy.avoid);
          if (success) {
            appendBattleLog(`${battleState.player.name}ã¯å›é¿ã«æˆåŠŸã—ãŸï¼æ¬¡ã®æ•µã®æ”»æ’ƒã‚’å›é¿`);
            battleState._playerDodged = true;
          } else {
            appendBattleLog(`${battleState.player.name}ã®å›é¿ã¯å¤±æ•—ã—ãŸã€‚`);
          }
          break;
        }
        case 'item': {
          // å›å¾©ã¯ãƒãƒˆãƒ«ã”ã¨ã«å›æ•°åˆ¶é™ï¼ˆä½“é¨“ç‰ˆãƒ«ãƒ¼ãƒ«ï¼‰
          if (!battleState) break;
          if (!('healsUsed' in battleState)) battleState.healsUsed = 0;
          const heal = 20;
          if ((battleState.healsUsed || 0) >= (battleState.healLimit || 3)) {
            appendBattleLog('ã‚‚ã†å›å¾©ã‚¢ã‚¤ãƒ†ãƒ ã¯ä½¿ãˆãªã„ï¼');
          } else {
            battleState.healsUsed = (battleState.healsUsed || 0) + 1;
            battleState.player.hp = Math.min(battleState.player.maxHp, battleState.player.hp + heal);
            appendBattleLog(`${battleState.player.name}ã¯ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ã£ãŸã€‚HPãŒ${heal}å›å¾© (${battleState.healsUsed}/${battleState.healLimit})`);
          }
          break;
        }
      }
      // end player turn
      battleState.turn = 'enemy';
      updateBattleUI();
      // enemy acts after short delay
      setTimeout(enemyTurn, 800);
    }

    function enemyTurn() {
      if (!battleState || battleState.turn !== 'enemy') return;
      // if player dodged
      if (battleState._playerDodged) {
        appendBattleLog(`${battleState.enemy.name}ã®æ”»æ’ƒã¯è™šã—ãç©ºã‚’åˆ‡ã£ãŸï¼`);
        battleState._playerDodged = false;
      } else {
        // æ•µã¯ä¸»äººå…¬ã‚’ç‹™ã†
        const dmg = Math.max(1, battleState.enemy.atk - (battleState.protagonist.def || 0));
        battleState.protagonist.hp -= dmg;
        appendBattleLog(`${battleState.enemy.name}ã®æ”»æ’ƒï¼${battleState.protagonist.name}ã¯${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
      }
      // reset temporary defense buff for protagonist
      if (battleState.protagonist.def > 3) battleState.protagonist.def = 3;
      // check protagonist defeat
      if (battleState.protagonist.hp <= 0) {
        appendBattleLog(`${battleState.protagonist.name}ã¯å€’ã‚ŒãŸâ€¦`);
        endBattle(false);
        return;
      }
      // back to player
      battleState.turn = 'player';
      updateBattleUI();
    }

    function endBattle(playerWon) {
      console.log('[endBattle] called, playerWon=', playerWon);
      // æˆ¦é—˜çµ‚äº†æ™‚ã¯å‹æ•—æ¼”å‡ºã‚’è¡Œã£ã¦ã‹ã‚‰é€šå¸¸ã®ã‚¯ãƒªãƒ¼ãƒ³ãƒŠãƒƒãƒ—ã‚’è¡Œã†
      const sceneImageDiv = document.getElementById('scene-image');
      const textOverlay = document.getElementById('scene-text-overlay');
      // æˆ¦é—˜ä¸­ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ãƒãƒ«ã‚„ãƒœã‚¿ãƒ³ãŒæ®‹ã£ã¦ã„ã‚‹ã¨é•å’Œæ„ŸãŒã‚ã‚‹ãŸã‚ã€å³åº§ã«å‰Šé™¤/ç„¡åŠ¹åŒ–ã™ã‚‹
      try {
        const panel = sceneImageDiv && sceneImageDiv.querySelector && sceneImageDiv.querySelector('.battle-actions-panel');
        if (panel) {
          // ã™ãã«éè¡¨ç¤ºã«ã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç„¡åŠ¹åŒ–
          panel.querySelectorAll('button').forEach(b => { try { b.disabled = true; } catch(e){} });
          panel.style.display = 'none';
        }
      } catch (e) { console.warn('endBattle: could not hide actions panel', e); }
      // çµæœè¡¨ç¤ºè¦ç´ ã‚’ä½œæˆ
      const result = document.createElement('div');
      result.className = 'battle-result';
      result.textContent = playerWon ? 'å‹åˆ©ï¼' : 'æ•—åŒ—â€¦';
      if (sceneImageDiv) {
        sceneImageDiv.appendChild(result);
        // å¼·åˆ¶çš„ã«é«˜ã„ z-index ã‚’è¨­å®šã—ã¦è¦‹ãˆãªã„å•é¡Œã‚’å›é¿
        try { result.style.zIndex = '99999'; } catch(e){}
        // å³æ™‚ã«ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§è¡¨ç¤ºã‚’ç¢ºä¿ï¼ˆCSSã®ç«¶åˆã§è¦‹ãˆãªã„å ´åˆã«å‚™ãˆã‚‹ï¼‰
        try {
          result.style.display = 'block';
          result.style.opacity = '1';
          result.style.pointerEvents = 'auto';
          result.style.transform = 'translate(-50%, -50%) scale(1)';
        } catch(e) {}
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ãƒˆãƒªã‚¬ãƒ¼ï¼ˆä½µç”¨ï¼‰
        setTimeout(() => { result.classList.add('show'); }, 20);
        console.log('[endBattle] appended result element, inDOM=', document.contains(result), 'parent=', sceneImageDiv ? sceneImageDiv.className : null);
        // å‹åˆ©æ™‚ã¯å ±é…¬ã‚’è¡¨ç¤ºãƒ»ä»˜ä¸
        if (playerWon) {
          try { awardRewards(battleState.enemy, result); } catch (e) { console.error('awardRewards error', e); }
          // æˆ¦é—˜ç”¨ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã€ç›¸æ£’ã®ä¸€è¨€æ¼”å‡ºã‚’è¡¨ç¤º
          try {
            const battleLogEl = document.getElementById('battle-log');
            if (battleLogEl) battleLogEl.innerHTML = '';
            if (textOverlay) {
              // Use the normal typewriter/å¼¾å¹• display for the companion's victory line
              textOverlay.innerHTML = '';
              const companionName = (battleState && battleState.companion && battleState.companion.name) ? battleState.companion.name : (localStorage.getItem('selected_companion') ? JSON.parse(localStorage.getItem('selected_companion')).name : 'ç›¸æ£’');
              const protagonistName = (battleState && battleState.protagonist && battleState.protagonist.name) ? battleState.protagonist.name : 'ä¸»äººå…¬';
              const line = `${companionName}ã€Œã‚„ã£ãŸã­ï¼${protagonistName}ï¼ã€`;
              // set as the only text block and display via existing showNextTextBlock flow
              currentTextBlocks = [ line.replace(/\n/g,'<br>') ];
              currentTextIndex = 0;
              textOverlayEl = document.getElementById('scene-text-overlay');
              if (textOverlayEl) textOverlayEl.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
              // show it; ensure both â–¼ ã¨ç”»é¢ã‚¯ãƒªãƒƒã‚¯ã§é€²ã‚ã‚‹ã‚ˆã†è£œåŠ©ãƒãƒ³ãƒ‰ãƒ©ã‚’è¿½åŠ 
              showNextTextBlock(() => {});
              try {
                // add a one-time click handler on the scene image that mirrors â–¼ behaviour
                const sceneImgDiv = document.getElementById('scene-image');
                if (sceneImgDiv) {
                  const clickHandler = function onSceneClick(e) {
                    try {
                      const nb = sceneImgDiv.querySelector('.scene-text-next');
                      if (nb && nb.style.display === 'block') {
                        // hide â–¼ and advance text (reuse same logic as showNextTextBlock onclick)
                        nb.style.display = 'none';
                        currentTextIndex++;
                        if (currentTextIndex < currentTextBlocks.length) {
                          showNextTextBlock();
                        } else {
                          sceneImgDiv.removeEventListener('click', onSceneClick);
                          sceneImgDiv.classList.remove('clickable');
                          // å¼¾å¹•ãŒå…¨ã¦çµ‚ã‚ã£ãŸã‚‰æˆ¦é—˜æ¼”å‡ºã‚’çµ‚äº†ã—æ¬¡ã®ã‚·ãƒ¼ãƒ³ã¸
                          if (typeof doCleanup === 'function') doCleanup();
                        }
                      }
                    } catch(err) { console.error('scene click handler error', err); }
                  };
                  sceneImgDiv.classList.add('clickable');
                  sceneImgDiv.addEventListener('click', clickHandler);
                }
              } catch(e) { console.error('add scene click helper error', e); }
            }
          } catch (e) { console.error('å‹åˆ©æ¼”å‡ºã‚¨ãƒ©ãƒ¼', e); }
        }
        // æ•—åŒ—æ™‚ã¯ã™ãã«å°‚ç”¨ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤ºã—ã¦ã‚¯ãƒªãƒƒã‚¯å¾…ã¡ã«ã™ã‚‹
        if (!playerWon) {
          try {
            // æ—¢ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãŒã‚ã‚‹å ´åˆã¯ä½œã‚‰ãªã„
            if (sceneImageDiv && !sceneImageDiv.querySelector('.defeat-overlay')) {
              let companionName = 'ç›¸æ£’';
              const sel = localStorage.getItem('selected_companion');
              if (sel) {
                try { const obj = JSON.parse(sel); if (obj && obj.name) companionName = obj.name; } catch(e){}
              }
              const protagonistName = (battleState && battleState.protagonist && battleState.protagonist.name) ? battleState.protagonist.name : 'ä¸»äººå…¬';
              const defeatOverlay = document.createElement('div');
              defeatOverlay.className = 'defeat-overlay';
              defeatOverlay.style.position = 'absolute';
              defeatOverlay.style.left = '0';
              defeatOverlay.style.top = '0';
              defeatOverlay.style.width = '100%';
              defeatOverlay.style.height = '100%';
              defeatOverlay.style.display = 'flex';
              defeatOverlay.style.alignItems = 'center';
              defeatOverlay.style.justifyContent = 'center';
              defeatOverlay.style.flexDirection = 'column';
              defeatOverlay.style.background = 'rgba(0,0,0,0)';
              defeatOverlay.style.color = '#fff';
              defeatOverlay.style.zIndex = '99998';
              defeatOverlay.style.cursor = 'pointer';
              defeatOverlay.style.transition = 'background 700ms ease';
              const speech = document.createElement('div');
              speech.className = 'defeat-speech';
              speech.style.fontSize = '20px';
              speech.style.padding = '20px';
              speech.style.textAlign = 'center';
              speech.style.maxWidth = '80%';
              speech.style.lineHeight = '1.6';
              speech.style.textShadow = '0 2px 6px rgba(0,0,0,0.8)';
              speech.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
              speech.innerHTML = `${companionName}ã€Œ${protagonistName}ï¼${protagonistName}...ç›®ã‚’è¦šã¾ã—ã¦ã€ãŠé¡˜ã„...ã€`;
              defeatOverlay.appendChild(speech);
              sceneImageDiv.style.position = 'relative';
              sceneImageDiv.appendChild(defeatOverlay);
              setTimeout(() => { defeatOverlay.style.background = 'rgba(0,0,0,0.86)'; }, 30);
              // attach click for flow to narration+choices
              defeatOverlay.addEventListener('click', function onDefClick(e){
                try { e.stopPropagation(); } catch(ex){}
                // remove overlay
                if (defeatOverlay && defeatOverlay.parentNode) defeatOverlay.parentNode.removeChild(defeatOverlay);
                // minimal cleanup
                try { const panel = sceneImageDiv.querySelector('.battle-actions-panel'); if (panel) panel.remove(); } catch(e){}
                if (textOverlay) { textOverlay.innerHTML = ''; textOverlay.classList.remove('in-battle'); textOverlay.style.pointerEvents = 'auto'; }
                // clear battle state
                battleState = null;
                // show scene1 then narration and choices
                showScene('rose');
                      if (choice.next === 'RETRY') {
                        gameState.hp = gameState.maxHp || 100;
                        saveGame(gameState);
                        showScene('scene1');
                      } else {
                        window.location.href = 'index.html';
                      }
                    });
            }
          } catch (e) { console.error('æ•—åŒ—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½œæˆã‚¨ãƒ©ãƒ¼', e); }
        }
      }
      // æˆ¦é—˜çµ‚äº†æ¼”å‡ºã¯æ™‚é–“çµŒéã§ã¯æ¶ˆã•ãšã€ã‚¯ãƒªãƒƒã‚¯ã§ã®ã¿çµ‚äº†ã•ã›ã‚‹
      let _cleanupCalled = false;
      const doCleanup = () => {
        if (_cleanupCalled) return; _cleanupCalled = true;
        // remove UI elements we added
        const overlay = document.querySelector('.battle-overlay');
        if (overlay) overlay.remove();
        if (sceneImageDiv) {
          const panel = sceneImageDiv.querySelector('.battle-actions-panel');
          if (panel) panel.remove();
          const center = sceneImageDiv.querySelector('.battle-center-name');
          if (center) center.remove();
          // remove result element if still present
          const r = sceneImageDiv.querySelector('.battle-result');
          if (r) r.remove();
          // remove any leftover next arrow
          const oldNext = sceneImageDiv.querySelector('.scene-text-next'); if (oldNext) oldNext.remove();
        }
        if (textOverlay) {
          textOverlay.innerHTML = '';
          textOverlay.style.pointerEvents = 'none';
          textOverlay.classList.remove('in-battle');
        }
        if (playerWon) {
          appendLog('æˆ¦é—˜ã«å‹åˆ©ã—ãŸï¼');
          // æ•µã‚’å€’ã—ãŸå ´åˆã€ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã®scene4ã¸é·ç§»ï¼ˆä¾‹ï¼‰
          showScene('scene4');
        } else {
          appendLog('ã‚ãªãŸã¯æ•—åŒ—ã—ãŸâ€¦');
          // æ•—åŒ—æ™‚ã¯ã“ã“ã§ã¯æ¼”å‡ºã®åˆ¶å¾¡ã‚’ã—ãªã„ï¼ˆæ—¢ã«å³æ™‚æ•—åŒ—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤ºã—ã¦ã„ã‚‹ï¼‰
        }
        // restore player's hp to gameState (guarded)
        try {
          gameState.hp = Math.max(0, (battleState && battleState.protagonist && typeof battleState.protagonist.hp === 'number') ? battleState.protagonist.hp : (gameState.hp || 0));
        } catch (e) {
          // ignore
        }
        // flush any pending battle messages into the battle-log before clearing state
        if (battleState && battleState._pendingLogs && battleState._pendingLogs.length > 0) {
          const log = document.getElementById('battle-log');
          if (log) {
            battleState._pendingLogs.forEach(m => {
              const d = document.createElement('div'); d.textContent = m;
              log.appendChild(d);
            });
            while (log.children.length > 3) log.removeChild(log.children[0]);
            log.scrollTop = log.scrollHeight;
          }
        }
        battleState = null;
      };
      const _clickHandler = (e) => {
        try {
          // ã‚‚ã—ã‚¯ãƒªãƒƒã‚¯ãŒæˆ¦é—˜ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å†…ã§ç™ºç”Ÿã—ãŸã‚‚ã®ãªã‚‰ç„¡è¦–ï¼ˆæ”»æ’ƒãƒœã‚¿ãƒ³ç­‰ï¼‰
          const panel = sceneImageDiv && sceneImageDiv.querySelector && sceneImageDiv.querySelector('.battle-actions-panel');
          if (panel && panel.contains(e.target)) return;
        } catch (ee) {}
        // ä»»æ„ã®ã‚¯ãƒªãƒƒã‚¯ã§æ¼”å‡ºã‚’ã‚¹ã‚­ãƒƒãƒ—
        doCleanup();
      };
      // å‹åˆ©æ™‚ã¯å³ä¸‹ã«â–¼ã‚’è¡¨ç¤ºã—ã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰æ¼”å‡ºã‚’çµ‚äº†ã™ã‚‹
      setTimeout(() => {
        try {
          if (playerWon && sceneImageDiv) {
            // remove any existing next arrow first
            const oldNext = sceneImageDiv.querySelector('.scene-text-next'); if (oldNext) oldNext.remove();
            const endBtn = document.createElement('div');
            endBtn.className = 'scene-text-next battle-result-next';
            endBtn.textContent = 'â–¼';
            // ensure visible
            endBtn.style.display = 'block';
            // append and handle click once
            sceneImageDiv.appendChild(endBtn);
            endBtn.addEventListener('click', (ev) => {
              try { ev.stopPropagation(); } catch(e){}
              _clickHandler(ev);
            }, { once: true });
          }
        } catch (e) { console.error('endBattle: could not add end button', e); }
      }, 50);
    }
  </script>
</body>
</html>