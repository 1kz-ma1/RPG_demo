<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>å†’é™º</title>
    <link rel="stylesheet" href="/static/rpg_style.css">
    <link rel="stylesheet" href="/static/rpg_choice.css">

    <div class="layout">
    <div class="header">
      <h1 id="scene-title">âš” å†’é™º</h1>
      <div class="header-stats">
        
        <div class="stat">
          <span>LV</span>
          <span class="stat-value" id="level">1</span>
        </div>
        <div class="stat">
          <span>HP</span>
          <span class="stat-value" id="hp">100</span>
        </div>
        <div class="stat">
          <span>ã‚¹ã‚³ã‚¢</span>
          <span class="stat-value" id="score">0</span>
        </div>
        <div class="header-menu-btns">
          <button class="menu-btn" onclick="openStats()">ğŸ“Š ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</button>
          <button class="menu-btn" onclick="openInventory()">ğŸ’ ã‚¢ã‚¤ãƒ†ãƒ </button>
          <button class="menu-btn" onclick="openMap()">ğŸ—º ãƒãƒƒãƒ—</button>
        </div>
      </div>
    </div>
    
    <div class="scene">
      <div class="scene-image" id="scene-image">
        <img id="scene-img" src="" alt="scene" style="max-width:100%; max-height:100%; border-radius:2px; display:none;" />
        <span id="image-placeholder">ç”»åƒæº–å‚™ä¸­...</span>
        <div class="scene-text-overlay" id="scene-text-overlay" style="display:block;"></div>
      </div>
    </div>
    
    <div class="scene-log">
      <div class="log-title">ğŸ“œ ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°</div>
      <div id="log" style="max-height: 300px; overflow-y: auto;"></div>
    </div>
    
    <div class="choices" id="choices"></div>
    
    <div class="menu">
      <button class="menu-btn" onclick="goBack()" style="margin-left: auto;">â† æˆ»ã‚‹</button>
    </div>
  </div>

  <script>
              // é¸æŠè‚¢ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤º
              function showChoicesOverlay(choices, onSelect) {
                // æ—¢å­˜ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å‰Šé™¤
                const old = document.getElementById('scene-choice-overlay');
                if (old) old.remove();
                const overlay = document.createElement('div');
                overlay.className = 'scene-choice-overlay';
                overlay.id = 'scene-choice-overlay';
                overlay.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
                const list = document.createElement('div');
                list.className = 'scene-choice-list';
                list.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
                choices.forEach((choice, idx) => {
                  const btn = document.createElement('button');
                  btn.className = 'scene-choice-btn';
                  btn.textContent = choice.text;
                  btn.onclick = (e) => {
                    e.stopPropagation();
                    overlay.remove();
                    if (onSelect) onSelect(choice, idx);
                  };
                  list.appendChild(btn);
                });
                overlay.appendChild(list);
                // ç”»åƒãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é‡ã­ã¦è¿½åŠ 
                const sceneImageDiv = document.getElementById('scene-image');
                if (sceneImageDiv) sceneImageDiv.appendChild(overlay);
              }
            // å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆé€²è¡Œç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
            let currentTextBlocks = [];
            let currentTextIndex = 0;
            let textOverlayEl = null;
            let nextBtnEl = null;

            // å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆã‚’1ã¤ãšã¤typewriterè¡¨ç¤ºã—ã€scene-imageå…¨ä½“ã‚¯ãƒªãƒƒã‚¯ã§æ¬¡ã¸
            function showNextTextBlock(callback) {
              if (!textOverlayEl) textOverlayEl = document.getElementById('scene-text-overlay');
              // â–¼ãƒœã‚¿ãƒ³ã¯æ¯å›æ–°è¦ç”Ÿæˆã—ã€å¼¾å¹•é€ã‚Šã”ã¨ã«appendã™ã‚‹
              nextBtnEl = document.createElement('div');
              nextBtnEl.className = 'scene-text-next';
              nextBtnEl.textContent = 'â–¼';
              nextBtnEl.style.display = 'none';
              nextBtnEl.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
              // ç”»åƒãƒ¬ã‚¤ãƒ¤ãƒ¼å³ä¸‹ã«å¸¸ã«æµ®ã‹ã›ã‚‹ãŸã‚scene-imageç›´ä¸‹ã«append
              const sceneImageDiv2 = document.getElementById('scene-image');
              if (sceneImageDiv2) {
                // æ—¢å­˜ã®nextBtnElã‚’é™¤å»
                const oldNext = sceneImageDiv2.querySelector('.scene-text-next');
                if (oldNext) oldNext.remove();
                sceneImageDiv2.appendChild(nextBtnEl);
              }
              const sceneImageDiv = document.getElementById('scene-image');
              if (sceneImageDiv) {
                sceneImageDiv.classList.add('clickable');
                sceneImageDiv.onclick = () => {
                  if (nextBtnEl.style.display === 'block') {
                    nextBtnEl.style.display = 'none';
                    currentTextIndex++;
                    if (currentTextIndex < currentTextBlocks.length) {
                      showNextTextBlock(callback);
                    } else {
                      sceneImageDiv.onclick = null;
                      sceneImageDiv.classList.remove('clickable');
                      if (callback) callback();
                    }
                  }
                };
              }
              textOverlayEl.innerHTML = '';
              if (currentTextIndex < currentTextBlocks.length) {
                // %ãƒ–ãƒ­ãƒƒã‚¯ã«åˆ°é”ã—ãŸã‚‰é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼
                if (currentTextBlocks[currentTextIndex] === '%') {
                  if (callback) callback();
                  return;
                }
                typeWriterText(textOverlayEl, currentTextBlocks[currentTextIndex], 28, () => {
                  nextBtnEl.style.display = 'block';
                });
              } else {
                // ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã®å ´åˆã§ã‚‚callbackã‚’å‘¼ã¶
                if (callback) callback();
              }
            }
          // Typewriterã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºã—ã€å®Œäº†æ™‚ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
          function typeWriterText(element, html, speed = 28, callback) {
            element.innerHTML = '';
            let i = 0;
            // HTMLã‚¿ã‚°ã‚’è€ƒæ…®ã—ã¦1æ–‡å­—ãšã¤å‡ºã™
            function type() {
              if (i >= html.length) {
                if (callback) callback();
                return;
              }
              // <br>ãªã©ã®ã‚¿ã‚°ã¯ä¸€æ°—ã«å‡ºã™
              if (html[i] === '<') {
                const close = html.indexOf('>', i);
                if (close !== -1) {
                  element.innerHTML += html.slice(i, close + 1);
                  i = close + 1;
                } else {
                  element.innerHTML += html[i++];
                }
              } else {
                element.innerHTML += html[i++];
              }
              setTimeout(type, speed);
            }
            type();
          }
        // --- é€²è¡Œãƒ»ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ä¿å­˜é››å½¢ ---
        const SAVE_KEY = 'rpg_save';

        function saveGame(state) {
          localStorage.setItem(SAVE_KEY, JSON.stringify(state));
          console.log('ã‚²ãƒ¼ãƒ é€²è¡Œã‚’ä¿å­˜:', state);
        }

        function loadGame() {
          const data = localStorage.getItem(SAVE_KEY);
          if (!data) return null;
          try {
            return JSON.parse(data);
          } catch (e) {
            return null;
          }
        }

        // ä¾‹: ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«é€²è¡ŒçŠ¶æ³ã‚’å¾©å…ƒ
        let gameState = loadGame() || {
          score: 0,
          level: 1,
          hp: 100,
          maxHp: 100,
          log: [],
          sceneId: 'start',
          items: []
        };
        // ã‚·ãƒ¼ãƒ³é·ç§»æ™‚ãªã©ã«saveGame(gameState)ã‚’å‘¼ã¶ã“ã¨ã§é€²è¡Œã‚’ä¿å­˜ã§ãã‚‹
    const sceneTitle = document.getElementById('scene-title');
    const sceneImage = document.getElementById('scene-image');
    const choices = document.getElementById('choices');
    const logEl = document.getElementById('log');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const hpEl = document.getElementById('hp');
    const cacheInfo = document.getElementById('cache-info');

    async function fetchScene() {
      const res = await fetch('/api/choose', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });
      
      if (!res.ok) {
        logEl.innerHTML = '<div class="log-entry damage">ã‚·ãƒ¼ãƒ³èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼</div>';
        return;
      }
      
      const data = await res.json();
      console.log('[fetchScene] Response:', data);
      console.log('[fetchScene] image_url:', data.image_url);
      console.log('[fetchScene] image_task_id:', data.image_task_id);
      console.log('[fetchScene] image_key:', data.image_key);
      renderScene(data);
    }

    function renderScene(data) {
      // Title
      sceneTitle.textContent = data.title || '???';
      
      // Image
      if (data.image_url) {
        // normalize leading slash so paths work under repo subpath (GitHub Pages)
        const imgUrl = (data.image_url && data.image_url.startsWith('/')) ? data.image_url.slice(1) : data.image_url;
        console.log('[renderScene] Setting image src to:', imgUrl);
        sceneImage.innerHTML = '<img id="scene-img" src="' + imgUrl + '" alt="Scene" onerror="console.error(\'Image load failed:\', this.src); this.style.border=\'2px solid red\';">';
      } else {
        console.log('[renderScene] No image_url, showing placeholder');
        sceneImage.innerHTML = '<span id="image-placeholder">[ ' + (data.title || 'Scene') + ' ]</span>';
      }

      // If server returned an image generation task id, poll it and update the image when ready
      if (data.image_task_id && data.image_key) {
        pollImageTask(data.image_task_id, data.image_key);
      }
      
      // Stats
      // Use actual HP from server
      if (data.hp !== undefined) {
        gameState.hp = data.hp;
      }
      if (data.max_hp !== undefined) {
        gameState.maxHp = data.max_hp;
      }
      
      // `data.score` may be a number or an object like { total: N, level: L }
      let numericScore = gameState.score;
      if (data.score !== undefined && data.score !== null) {
        if (typeof data.score === 'object') {
          numericScore = Number(data.score.total || data.score.value || numericScore) || numericScore;
        } else {
          numericScore = Number(data.score) || numericScore;
        }
      }
      gameState.score = numericScore;
      // level: prefer provided level if present
      if (data.score && typeof data.score === 'object' && data.score.level) {
        gameState.level = Number(data.score.level) || gameState.level;
      } else {
        gameState.level = Math.max(1, Math.floor(gameState.score / 10) + 1);
      }
      
      scoreEl.textContent = gameState.score;
      levelEl.textContent = gameState.level;
      hpEl.textContent = gameState.hp + '/' + gameState.maxHp;
      
      // Cache badge
      if (data.cache_hit) {
        cacheInfo.style.display = 'inline-block';
      } else {
        cacheInfo.style.display = 'none';
      }
      
      // Log
      if (data.log && data.log.length > 0) {
        logEl.innerHTML = '';
        data.log.slice(-10).forEach(entry => {
          const div = document.createElement('div');
          div.className = 'log-entry';
          if (entry.indexOf('ãƒ€ãƒ¡ãƒ¼ã‚¸') >= 0) {
            div.classList.add('damage');
          } else if (entry.indexOf('å›å¾©') >= 0) {
            div.classList.add('recovery');
          } else if (entry.indexOf('é¸æŠ') >= 0 || entry.indexOf('å®Ÿè¡Œ') >= 0) {
            div.classList.add('action');
          }
          div.textContent = entry;
          logEl.appendChild(div);
        });
      }
      
      // Choicesï¼ˆã“ã“ã§ã¯ä½•ã‚‚å‡ºã•ãªã„ã€‚showSceneã§å¼¾å¹•é€ã‚Šå®Œäº†æ™‚ã®ã¿è¡¨ç¤ºï¼‰
      choices.innerHTML = '';
    }

    // Poll the task status endpoint until ready, then update the scene image src
    function pollImageTask(taskId, imageKey) {
      console.log('[pollImageTask] Starting poll for taskId:', taskId, 'imageKey:', imageKey);
      const attempt = async () => {
        try {
          const res = await fetch('/api/tasks/' + encodeURIComponent(taskId));
          if (!res.ok) {
            console.warn('[pollImageTask] Response not OK:', res.status);
            return;
          }
          const j = await res.json();
          console.log('[pollImageTask] Status:', j);
          if (j.ready) {
            // Replace image src with generated file (cache-bust)
            const img = document.getElementById('scene-img');
            const url = 'media/generated/' + encodeURIComponent(imageKey) + '.png?t=' + Date.now();
            console.log('[pollImageTask] Task ready! Setting image to:', url);
            if (img) {
              img.src = url;
              img.onerror = () => console.error('[pollImageTask] Image load failed:', url);
            } else {
              sceneImage.innerHTML = '<img id="scene-img" src="' + url + '" alt="Scene" onerror="console.error(\'Image load failed:\', this.src)">';
            }
            // show cache badge
            cacheInfo.style.display = 'inline-block';
          } else {
            // try again in 1500ms
            console.log('[pollImageTask] Not ready yet, polling again...');
            setTimeout(attempt, 1500);
          }
        } catch (e) {
          console.error('[pollImageTask] Error:', e);
          setTimeout(attempt, 2000);
        }
      };
      attempt();
    }

    async function selectChoice(choice, idx) {
      console.log('[selectChoice] Selected:', choice);
      
      // Disable all choices while loading
      document.querySelectorAll('.choice-btn').forEach(b => {
        b.disabled = true;
      });
      
      try {
        const res = await fetch('/api/choose', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ choice: choice })
        });
        
        if (!res.ok) {
          console.error('[selectChoice] Error response:', res.status);
          logEl.innerHTML += '<div class="log-entry damage">é¸æŠå‡¦ç†ã‚¨ãƒ©ãƒ¼</div>';
          return;
        }
        
        const data = await res.json();
        console.log('[selectChoice] Response:', data);
        renderScene(data);
      } catch (e) {
        console.error('[selectChoice] Exception:', e);
        logEl.innerHTML += '<div class="log-entry damage">é€šä¿¡ã‚¨ãƒ©ãƒ¼</div>';
      } finally {
        // Re-enable choices
        document.querySelectorAll('.choice-btn').forEach(b => {
          b.disabled = false;
        });
      }
    }

    function openStats() {
      alert('ğŸ“Š ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹\n\nãƒ¬ãƒ™ãƒ«: ' + gameState.level + '\nHP: ' + gameState.hp + '/' + gameState.maxHp + '\nã‚¹ã‚³ã‚¢: ' + gameState.score);
    }

    async function openInventory() {
      try {
        const res = await fetch('/api/inventory', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!res.ok) {
          alert('ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
          return;
        }
        
        const data = await res.json();
        console.log('[openInventory] Data:', data);
        
        let message = 'ğŸ’ æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ \n\n';
        
        if (data.items && Object.keys(data.items).length > 0) {
          for (const [itemName, count] of Object.entries(data.items)) {
            if (count > 0) {
              message += `ãƒ»${itemName} Ã— ${count}\n`;
            }
          }
        } else {
          message += 'ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŒã£ã¦ã„ã¾ã›ã‚“';
        }
        
        if (data.companions && data.companions.length > 0) {
          message += '\n\nâš”ï¸ ä»²é–“:\n';
          data.companions.forEach(comp => {
            message += `ãƒ»${comp.name} (${comp.role})\n`;
          });
        }
        
        alert(message);
      } catch (e) {
        console.error('[openInventory] Error:', e);
        alert('ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      }
    }

    function openMap() {
      alert('ğŸ—º ãƒãƒƒãƒ—\n\n(å®Ÿè£…äºˆå®š)');
    }

    function goBack() {
      if (confirm('å†’é™ºã‚’çµ‚ã‚ã‚Šã¾ã™ã‹ï¼Ÿ')) {
        window.location.href = '/companions/select_page';
      }
    }

    // --- JSONãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿é››å½¢ ---
    async function loadJSON(path) {
      const res = await fetch(path);
      if (!res.ok) throw new Error('ãƒ‡ãƒ¼ã‚¿å–å¾—å¤±æ•—: ' + path);
      return await res.json();
    }

    // ä¾‹: ãƒ‡ãƒ¼ã‚¿ã‚’ã¾ã¨ã‚ã¦èª­ã¿è¾¼ã‚€
    let storyData, charData, itemData;
    Promise.all([
      loadJSON('static/data/story.json'),
      loadJSON('static/data/characters.json'),
      loadJSON('static/data/items.json')
    ]).then(([story, chars, items]) => {
      storyData = story;
      charData = chars;
      itemData = items;
      // ã“ã“ã§ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚„æç”»å‡¦ç†ã‚’å‘¼ã¶
      console.log('ã‚¹ãƒˆãƒ¼ãƒªãƒ¼', storyData);
      console.log('ã‚­ãƒ£ãƒ©', charData);
      console.log('ã‚¢ã‚¤ãƒ†ãƒ ', itemData);
      // ä¾‹: æœ€åˆã®ã‚·ãƒ¼ãƒ³ã‚’è¡¨ç¤º
      showScene('scene1');
    }).catch(e => {
      alert('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + e);
    });

    // ã‚·ãƒ¼ãƒ³è¡¨ç¤ºã®é››å½¢
    function showScene(sceneId) {
        currentTextBlocks = [];
        currentTextIndex = 0;
      // --- ã‚·ãƒ¼ãƒ³é€²è¡Œæ™‚ã«UIé‡è¤‡ã‚’é˜²ããŸã‚ã€scene-imageé…ä¸‹ã®ä¸è¦ãªè¦ç´ ã‚’æ¯å›ã‚¯ãƒªã‚¢ ---
      const sceneImageDiv = document.getElementById('scene-image');
      if (sceneImageDiv) {
        // ã‚·ãƒ¼ãƒ³é€²è¡Œæ™‚ã€scene-imageé…ä¸‹ã‚’å®Œå…¨ã‚¯ãƒªã‚¢ï¼ˆå…¨UIç«¶åˆé˜²æ­¢ï¼‰
        sceneImageDiv.innerHTML = '';
        // ç”»åƒè¦ç´ ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’å†ç”Ÿæˆ
        const img = document.createElement('img');
        img.id = 'scene-img';
        img.src = '';
        img.alt = 'scene';
        img.style.maxWidth = '100%';
        img.style.maxHeight = '100%';
        img.style.borderRadius = '2px';
        img.style.display = 'none';
        sceneImageDiv.appendChild(img);
        const placeholder = document.createElement('span');
        placeholder.id = 'image-placeholder';
        placeholder.textContent = 'ç”»åƒæº–å‚™ä¸­...';
        sceneImageDiv.appendChild(placeholder);
        const textOverlay = document.createElement('div');
        textOverlay.className = 'scene-text-overlay';
        textOverlay.id = 'scene-text-overlay';
        textOverlay.style.display = 'block';
        sceneImageDiv.appendChild(textOverlay);
      }
      // ãƒ‡ãƒãƒƒã‚°: å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆã¨è¦ç´ ã®çŠ¶æ…‹ã‚’å‡ºåŠ›
      console.log('[å¼¾å¹•ãƒ‡ãƒãƒƒã‚°] sceneId:', sceneId);
      // ãƒ‡ãƒãƒƒã‚°ç”¨: ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³IDã¨å…¨ã‚·ãƒ¼ãƒ³IDä¸€è¦§ã‚’å‡ºåŠ›
      console.log("currentSceneId:", sceneId);
      if (storyData && storyData.scenes) {
        console.log("scenes ids:", storyData.scenes.map(s => s.id));
      } else {
        console.log("storyDataã¾ãŸã¯scenesãŒæœªå®šç¾©");
      }
      const scene = storyData.scenes.find(s => s.id === sceneId);
      if (!scene) {
        alert('ã‚·ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ' + sceneId);
        return;
      }
      // æˆ¦é—˜ãƒˆãƒªã‚¬ãƒ¼: scene3Bã¯æˆ¦é—˜ã«ç§»è¡Œ
      if (scene.id === 'scene3B') {
        // æ•µã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ç°¡æ˜“å®šç¾©ï¼ˆå¿…è¦ã«å¿œã˜ã¦story.jsonã‚„åˆ¥å®šç¾©ã¸ç§»å‹•å¯ï¼‰
        const enemy = { id: 'shadow', name: 'é»’ãå½±', hp: 40, maxHp: 40, atk: 7, def: 1, avoid: 8 };
        startBattle(enemy, scene);
        return;
      }
      if (currentTextBlocks.length > 0) {
        showNextTextBlock(() => {
          // å¼¾å¹•ãƒ†ã‚­ã‚¹ãƒˆã‚’ã™ã¹ã¦å‡ºåŠ›ã—ãã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
          console.log('[å¼¾å¹•å®Œäº†] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'currentTextIndex:', currentTextIndex, 'currentTextBlocks:', currentTextBlocks);
          if (scene.choices && Array.isArray(scene.choices) && scene.choices.length > 0) {
            console.log('[é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'choices:', scene.choices);
            showChoicesOverlay(scene.choices, (choice) => {
              // é¸æŠè‚¢ã‚¯ãƒªãƒƒã‚¯æ™‚ã€æ¬¡ã®ã‚·ãƒ¼ãƒ³ã¸
              if (choice.next) showScene(choice.next);
            });
          } else {
            console.log('[é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'â†’ é¸æŠè‚¢ãªã—');
          }
        });
      } else if (scene.choices && Array.isArray(scene.choices) && scene.choices.length > 0) {
        // ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ã‚‚é¸æŠè‚¢ãŒã‚ã‚Œã°ãƒ€ãƒŸãƒ¼å¼¾å¹•é€ã‚Šã‚’1å›ç™ºç”Ÿã•ã›ã¦ã‚¯ãƒªãƒƒã‚¯å¾Œã«é¸æŠè‚¢ã‚’è¡¨ç¤º
        currentTextBlocks = [''];
        currentTextIndex = 0;
        showNextTextBlock(() => {
          console.log('[å¼¾å¹•å®Œäº†:ãƒ€ãƒŸãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'currentTextIndex:', currentTextIndex, 'currentTextBlocks:', currentTextBlocks);
          console.log('[é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'choices:', scene.choices);
          showChoicesOverlay(scene.choices, (choice) => {
            if (choice.next) showScene(choice.next);
          });
        });
      } else {
        // ãƒ†ã‚­ã‚¹ãƒˆã‚‚é¸æŠè‚¢ã‚‚ãªã„å ´åˆ
        console.log('[å¼¾å¹•ã‚¹ã‚­ãƒƒãƒ—] ã‚·ãƒ¼ãƒ³ID:', sceneId, 'currentTextBlocksãŒç©ºãƒ»é¸æŠè‚¢ã‚‚ãªã—');
      }
      // ç›¸æ£’åãƒ»å½¹è·ã‚’localStorageã‹ã‚‰å–å¾—
      let companionName = 'ãƒªã‚£ãƒŠ';
      let companionRole = 'priest';
      try {
        const sel = localStorage.getItem('selected_companion');
        if (sel) {
          const obj = JSON.parse(sel);
          if (obj && obj.name) companionName = obj.name;
          if (obj && obj.role) companionRole = obj.role;
        }
      } catch(e) {}
      // ã‚¿ã‚¤ãƒˆãƒ«
      document.getElementById('scene-title').textContent = (scene.title || 'æ—…è·¯ã®å§‹ã¾ã‚Š');
      // æœ¬æ–‡ï¼ˆ${companion_name}ã‚’ç½®æ›ï¼‰
      let text = scene.text || '';
      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      text = text.replace(/\$\{companion_name\}/g, companionName).replace(/\$\{companion_role\}/g, companionRole);
      // %ãƒˆãƒªã‚¬ãƒ¼å¯¾å¿œ: %ãŒã‚ã‚Œã°ãã“ã¾ã§å¼¾å¹•é€ã‚Šã€%ã§é¸æŠè‚¢è¡¨ç¤ºã€‚ãªã‘ã‚Œã°å¾“æ¥é€šã‚Šã€‚
      let rawBlocks = text.split(/\n\n/).map(s => s.trim());
      let triggerIndex = rawBlocks.findIndex(b => b === '%');
      if (triggerIndex !== -1) {
        // %ãŒã‚ã‚Œã°ãã“ã¾ã§ã‚’å¼¾å¹•é€ã‚Šã€%ã§é¸æŠè‚¢ãƒˆãƒªã‚¬ãƒ¼
        currentTextBlocks = rawBlocks.slice(0, triggerIndex).map(s => s.replace(/\n/g, '<br>')).filter(s => s.length > 0);
        currentTextBlocks.push('%'); // ãƒˆãƒªã‚¬ãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ˜ç¤ºçš„ã«å…¥ã‚Œã‚‹
      } else {
        // %ãŒãªã‘ã‚Œã°å¾“æ¥é€šã‚Š
        currentTextBlocks = rawBlocks.map(s => s.replace(/\n/g, '<br>')).filter(s => s.length > 0);
      }
      currentTextIndex = 0;
      textOverlayEl = document.getElementById('scene-text-overlay');
      if (textOverlayEl) textOverlayEl.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
      showNextTextBlock(() => {
        // %ãƒˆãƒªã‚¬ãƒ¼ã¾ãŸã¯å¼¾å¹•å®Œäº†æ™‚ã«é¸æŠè‚¢
        if (
          (currentTextBlocks.length > 0 && currentTextBlocks[currentTextBlocks.length - 1] === '%' && currentTextIndex === currentTextBlocks.length - 1)
          || (currentTextBlocks.length > 0 && currentTextBlocks[currentTextBlocks.length - 1] !== '%' && currentTextIndex === currentTextBlocks.length)
        ) {
          if (scene.choices && Array.isArray(scene.choices) && scene.choices.length > 0) {
            showChoicesOverlay(scene.choices, (choice) => {
              if (choice.next) showScene(choice.next);
            });
          }
        }
      });
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã«è¨˜éŒ²
      const logEl = document.getElementById('log');
      if (logEl) {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.style.fontFamily = "'Noto Serif JP', 'æ¸¸æ˜æœ', 'Yu Mincho', 'MS Mincho', serif";
        // ç™ºè¨€è€…åã®æŠ½å‡ºï¼ˆã€Œã‚­ãƒ£ãƒ©åã€Œã€ã€ã‚„${companion_name}ãªã©ï¼‰
        let logText = text.replace(/<br>/g, ' ');
        // XSSå¯¾ç­–ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        function escapeHtml(str) {
          return str.replace(/[&<>"']/g, function(tag) {
            const chars = {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'};
            return chars[tag] || tag;
          });
        }
        // \nã‚’æ”¹è¡Œã¨ã—ã¦åæ˜ 
        entry.innerHTML = escapeHtml(logText).replace(/\n/g, '<br>');
        logEl.appendChild(entry);
        // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸€ç•ªä¸‹ã¸
        logEl.scrollTop = logEl.scrollHeight;
      }
      // ç”»åƒ
      const sceneImg = document.getElementById('scene-img');
      const imagePlaceholder = document.getElementById('image-placeholder');
      if (scene.image) {
        let imgPath = scene.image;
        imgPath = imgPath.replace(/\$\{companion_role\}/g, companionRole);
        let absPath = '';
        if (imgPath.startsWith('pregenerated/')) {
          absPath = 'media/pregenerated/' + imgPath.substring('pregenerated/'.length);
        } else if (imgPath.startsWith('/')) {
          absPath = imgPath;
        } else {
          absPath = 'media/characters/' + imgPath;
        }
        console.log("ç”»åƒãƒ‘ã‚¹:", absPath);
        sceneImg.src = absPath;
        sceneImg.style.display = '';
        sceneImg.onerror = function() {
          this.style.display = 'none';
          if (imagePlaceholder) imagePlaceholder.textContent = 'ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
        };
        if (imagePlaceholder) imagePlaceholder.style.display = 'none';
      } else {
        sceneImg.style.display = 'none';
        if (imagePlaceholder) {
          imagePlaceholder.textContent = 'ç”»åƒãªã—';
          imagePlaceholder.style.display = '';
        }
      }
      console.log('ã‚·ãƒ¼ãƒ³è¡¨ç¤º:', scene);
    }

    // --- æˆ¦é—˜ãƒ­ã‚¸ãƒƒã‚¯ ---
    let battleState = null;

    function startBattle(enemy, sceneContext) {
      if (!battleState) battleState = {};
      // äºŒé‡èµ·å‹•é˜²æ­¢ãƒ•ãƒ©ã‚°
      if (battleState._started) return;
      battleState._started = true;
      battleState.enemy = Object.assign({}, enemy);
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ä¸»äººå…¬ + ç›¸æ£’ã€‚ç›¸æ£’ã®atkã®2å€ãŒä¸»äººå…¬ã®atk
      const sel = localStorage.getItem('selected_companion');
      const companionName = sel ? JSON.parse(sel).name : 'ç›¸æ£’';
      // åŸºæœ¬å€¤ï¼ˆèª¿æ•´å¯ï¼‰
      const companionDefault = { hp: 40, maxHp: 40, atk: 8, def: 2, avoid: 6 };
      battleState.companion = Object.assign({}, companionDefault, { name: companionName });
      battleState.protagonist = {
        name: 'ä¸»äººå…¬',
        hp: gameState.hp || 100,
        maxHp: gameState.maxHp || 100,
        atk: (battleState.companion.atk || companionDefault.atk) * 2,
        def: 3,
        avoid: 6
      };
      // convenience alias for older code paths
      battleState.player = battleState.protagonist;
      battleState.turn = 'player';
      renderBattleUI(sceneContext);
    }

    function renderBattleUI(sceneContext) {
      const sceneImageDiv = document.getElementById('scene-image');
      const sceneImg = document.getElementById('scene-img');
      const imagePlaceholder = document.getElementById('image-placeholder');
      // ç”»åƒã‚’æˆ¦é—˜ç”¨ã«åˆ‡ã‚Šæ›¿ãˆï¼ˆpregenerated/scene3-battleï¼‰
      if (sceneImg) {
        sceneImg.src = 'media/pregenerated/scene3-battle.jpg';
        sceneImg.style.display = '';
      }
      if (imagePlaceholder) imagePlaceholder.style.display = 'none';

      // å¼¾å¹•ï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼‰ã‚’éè¡¨ç¤ºã«ã—ã¦ã€ãã®é ˜åŸŸã«æˆ¦é—˜ã‚³ãƒãƒ³ãƒ‰ã‚’ç½®ã
      const textOverlay = document.getElementById('scene-text-overlay');
      if (textOverlay) {
        textOverlay.innerHTML = '';
        textOverlay.style.pointerEvents = 'auto';
        textOverlay.style.display = 'block';
      }

      // è¡¨ç¤ºã¯æ•µåã®ã¿ï¼ˆä¸­å¤®ï¼‰
      // ç”»åƒä¸­å¤®ã«æ•µåã‚’è¡¨ç¤º (ä¸Šã§å–å¾—ã—ãŸ `sceneImageDiv` ã‚’åˆ©ç”¨)
      // remove existing center name
      const oldCenter = sceneImageDiv.querySelector('.battle-center-name');
      if (oldCenter) oldCenter.remove();
      const centerName = document.createElement('div');
      centerName.className = 'battle-center-name';
      centerName.textContent = battleState.enemy.name;
      sceneImageDiv.appendChild(centerName);

      // actions: ç”»åƒä¸Šã«ç‹¬ç«‹ã•ã›ã‚‹ãƒ‘ãƒãƒ«ã¨ã—ã¦é…ç½®ï¼ˆå¼¾å¹•ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã¯åˆ†é›¢ï¼‰
      let actionsPanel = sceneImageDiv.querySelector('.battle-actions-panel');
      if (actionsPanel) actionsPanel.remove();
      actionsPanel = document.createElement('div');
      actionsPanel.className = 'battle-actions-panel';
      actionsPanel.style.pointerEvents = 'auto';
      const btnAttack = document.createElement('button'); btnAttack.className='battle-action-btn'; btnAttack.textContent='æ”»æ’ƒ'; btnAttack.onclick = () => playerAction('attack');
      const btnDefend = document.createElement('button'); btnDefend.className='battle-action-btn'; btnDefend.textContent='é˜²å¾¡'; btnDefend.onclick = () => playerAction('defend');
      const btnDodge = document.createElement('button'); btnDodge.className='battle-action-btn'; btnDodge.textContent='å›é¿'; btnDodge.onclick = () => playerAction('dodge');
      const btnItem = document.createElement('button'); btnItem.className='battle-action-btn'; btnItem.textContent='ã‚¢ã‚¤ãƒ†ãƒ '; btnItem.onclick = () => playerAction('item');
      actionsPanel.appendChild(btnAttack); actionsPanel.appendChild(btnDefend); actionsPanel.appendChild(btnDodge); actionsPanel.appendChild(btnItem);
      sceneImageDiv.appendChild(actionsPanel);

      // battle display (å¼¾å¹•è¡¨ç¤ºç”¨): æ¯å›ä¸Šæ›¸ãã—ã¦è¡¨ç¤ºã™ã‚‹é ˜åŸŸ
      let battleDisplay = textOverlay.querySelector('.battle-display');
      if (!battleDisplay) {
        battleDisplay = document.createElement('div');
        battleDisplay.className = 'battle-display';
        battleDisplay.style.minHeight = '48px';
        battleDisplay.style.marginBottom = '8px';
        textOverlay.appendChild(battleDisplay);
      }

      // battle log area (å±¥æ­´): è¡¨ç¤ºã¯æ®‹ã™ãŒä»¶æ•°ã‚’åˆ¶é™
      let log = textOverlay.querySelector('.battle-log');
      if (!log) {
        log = document.createElement('div');
        log.className = 'battle-log';
        log.id = 'battle-log';
        textOverlay.appendChild(log);
      }
      appendBattleLog('æˆ¦é—˜é–‹å§‹ï¼æ•µãŒç¾ã‚ŒãŸï¼š' + battleState.enemy.name);
      battleState.turn = 'player';
      updateBattleUI();
    }

    function appendBattleLog(msg) {
      const log = document.getElementById('battle-log');
      const battleDisplay = document.querySelector('.battle-display');
      if (!log && !battleDisplay) return;
      // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
      function escapeHtml(str) {
        return (''+str).replace(/[&<>\"]/g, function(ch){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'})[ch] || ch; });
      }
      // å¼¾å¹•è¡¨ç¤ºï¼ˆä¸Šæ›¸ãã§1è¡Œãšã¤è¡¨ç¤ºï¼‰: è¡¨ç¤ºä¸­ã®è¡Œã¯å±¥æ­´ã«å³è¿½åŠ ã›ãšã€æ¬¡ã®è¡ŒãŒæ¥ãŸã¨ãã«å‰ã®è¡Œã‚’å±¥æ­´ã¸ç§»ã™æ–¹å¼
      if (battleDisplay) {
        // initialize pending buffer on battleState
        if (!battleState) battleState = {};
        if (!battleState._pendingLogs) battleState._pendingLogs = [];
        // flush pending logs into visible history before showing the next message
        if (battleState._pendingLogs.length > 0 && log) {
          battleState._pendingLogs.forEach(m => {
            const d = document.createElement('div'); d.textContent = m;
            log.appendChild(d);
          });
          while (log.children.length > 2) log.removeChild(log.children[0]);
          log.scrollTop = log.scrollHeight;
          battleState._pendingLogs = [];
        }
        // show current message in battleDisplay, then store it as pending (not immediately in history)
        typeWriterText(battleDisplay, escapeHtml(msg), 20, () => {
          battleState._pendingLogs.push(msg);
          // keep pending buffer small
          while (battleState._pendingLogs.length > 2) battleState._pendingLogs.shift();
        });
      } else {
        // battleDisplay ãŒãªã„å ´åˆã¯é€šå¸¸ã®å±¥æ­´è¿½åŠ 
        const d = document.createElement('div'); d.textContent = msg;
        log.appendChild(d);
        while (log.children.length > 2) log.removeChild(log.children[0]);
        log.scrollTop = log.scrollHeight;
      }
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã¸è¿½è¨˜ (ãƒ¡ã‚¤ãƒ³ç”»é¢ç”¨)
    function appendLog(msg) {
      const logElMain = document.getElementById('log');
      if (!logElMain) return;
      const div = document.createElement('div');
      div.className = 'log-entry action';
      div.textContent = msg;
      logElMain.appendChild(div);
      logElMain.scrollTop = logElMain.scrollHeight;
    }

    function updateBattleUI() {
      const textOverlay = document.getElementById('scene-text-overlay');
      if (!textOverlay) return;
      const enemyFill = textOverlay.querySelector('.hp-fill[data-role="enemy"]');
      const protFill = textOverlay.querySelector('.hp-fill[data-role="protagonist"]');
      const compFill = textOverlay.querySelector('.hp-fill[data-role="companion"]');
      if (enemyFill) enemyFill.style.width = Math.max(0,Math.round((battleState.enemy.hp/battleState.enemy.maxHp)*100)) + '%';
      if (protFill) protFill.style.width = Math.max(0,Math.round((battleState.protagonist.hp/battleState.protagonist.maxHp)*100)) + '%';
      if (compFill) compFill.style.width = Math.max(0,Math.round((battleState.companion.hp/battleState.companion.maxHp)*100)) + '%';
      // disable actions if not player's turn
      textOverlay.querySelectorAll('.battle-action-btn').forEach(b => b.disabled = (battleState.turn !== 'player'));
    }

    function playerAction(action) {
      if (!battleState || battleState.turn !== 'player') return;
      switch(action) {
        case 'attack': {
          // ä¸»äººå…¬æ”»æ’ƒ
          const p = battleState.protagonist;
          const e = battleState.enemy;
          const dmg1 = Math.max(1, p.atk - (e.def || 0));
          e.hp -= dmg1;
          appendBattleLog(`${p.name}ã®æ”»æ’ƒï¼${e.name}ã«${dmg1}ãƒ€ãƒ¡ãƒ¼ã‚¸`);
          if (e.hp <= 0) {
            appendBattleLog(`${e.name} ã‚’å€’ã—ãŸï¼`);
            endBattle(true);
            return;
          }
          // ç›¸æ£’æ”»æ’ƒ
          const c = battleState.companion;
          const dmg2 = Math.max(1, c.atk - (e.def || 0));
          e.hp -= dmg2;
          appendBattleLog(`${c.name}ã®è¿½æ’ƒï¼${e.name}ã«${dmg2}ãƒ€ãƒ¡ãƒ¼ã‚¸`);
          if (e.hp <= 0) {
            appendBattleLog(`${e.name} ã‚’å€’ã—ãŸï¼`);
            endBattle(true);
            return;
          }
          break;
        }
        case 'defend': {
          battleState.player.def += 2;
          appendBattleLog(`${battleState.player.name}ã¯é˜²å¾¡ã®æ§‹ãˆã€‚æ¬¡ã®è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è»½æ¸›ã—ã¾ã™ã€‚`);
          break;
        }
        case 'dodge': {
          // å›é¿ã¯æˆåŠŸç‡ã§å‡¦ç†
          const success = Math.random()*100 < 30 + (battleState.player.avoid - battleState.enemy.avoid);
          if (success) {
            appendBattleLog(`${battleState.player.name}ã¯å›é¿ã«æˆåŠŸã—ãŸï¼æ¬¡ã®æ•µã®æ”»æ’ƒã‚’å›é¿`);
            battleState._playerDodged = true;
          } else {
            appendBattleLog(`${battleState.player.name}ã®å›é¿ã¯å¤±æ•—ã—ãŸã€‚`);
          }
          break;
        }
        case 'item': {
          // ç°¡æ˜“: å›å¾©ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’1ã¤æ¶ˆè²»ï¼ˆå®Ÿè£…ã¯æš«å®šï¼‰
          const heal = 20;
          battleState.player.hp = Math.min(battleState.player.maxHp, battleState.player.hp + heal);
          appendBattleLog(`${battleState.player.name}ã¯ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ã£ãŸã€‚HPãŒ${heal}å›å¾©`);
          break;
        }
      }
      // end player turn
      battleState.turn = 'enemy';
      updateBattleUI();
      // enemy acts after short delay
      setTimeout(enemyTurn, 800);
    }

    function enemyTurn() {
      if (!battleState || battleState.turn !== 'enemy') return;
      // if player dodged
      if (battleState._playerDodged) {
        appendBattleLog(`${battleState.enemy.name}ã®æ”»æ’ƒã¯è™šã—ãç©ºã‚’åˆ‡ã£ãŸï¼`);
        battleState._playerDodged = false;
      } else {
        // æ•µã¯ä¸»äººå…¬ã‚’ç‹™ã†
        const dmg = Math.max(1, battleState.enemy.atk - (battleState.protagonist.def || 0));
        battleState.protagonist.hp -= dmg;
        appendBattleLog(`${battleState.enemy.name}ã®æ”»æ’ƒï¼${battleState.protagonist.name}ã¯${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸ`);
      }
      // reset temporary defense buff for protagonist
      if (battleState.protagonist.def > 3) battleState.protagonist.def = 3;
      // check protagonist defeat
      if (battleState.protagonist.hp <= 0) {
        appendBattleLog(`${battleState.protagonist.name}ã¯å€’ã‚ŒãŸâ€¦`);
        endBattle(false);
        return;
      }
      // back to player
      battleState.turn = 'player';
      updateBattleUI();
    }

    function endBattle(playerWon) {
      // remove UI elements we added
      const overlay = document.querySelector('.battle-overlay');
      if (overlay) overlay.remove();
      const sceneImageDiv = document.getElementById('scene-image');
      if (sceneImageDiv) {
        const panel = sceneImageDiv.querySelector('.battle-actions-panel');
        if (panel) panel.remove();
        const center = sceneImageDiv.querySelector('.battle-center-name');
        if (center) center.remove();
      }
      const textOverlay = document.getElementById('scene-text-overlay');
      if (textOverlay) {
        textOverlay.innerHTML = '';
        textOverlay.style.pointerEvents = 'none';
      }
      if (playerWon) {
        appendLog('æˆ¦é—˜ã«å‹åˆ©ã—ãŸï¼');
        // æ•µã‚’å€’ã—ãŸå ´åˆã€ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã®scene4ã¸é·ç§»ï¼ˆä¾‹ï¼‰
        showScene('scene4');
      } else {
        appendLog('ã‚ãªãŸã¯æ•—åŒ—ã—ãŸâ€¦ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç†ã¸');
        // æ•—åŒ—æ™‚ã¯ç°¡æ˜“çš„ã«ãƒªãƒ­ãƒ¼ãƒ‰ã‚„ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã™ãªã©
        alert('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼');
        window.location.reload();
      }
      // restore player's hp to gameState (ç°¡æ˜“)
      gameState.hp = Math.max(0, battleState.protagonist.hp);
      // flush any pending battle messages into the battle-log before clearing state
      if (battleState && battleState._pendingLogs && battleState._pendingLogs.length > 0) {
        const log = document.getElementById('battle-log');
        if (log) {
          battleState._pendingLogs.forEach(m => {
            const d = document.createElement('div'); d.textContent = m;
            log.appendChild(d);
          });
          while (log.children.length > 2) log.removeChild(log.children[0]);
          log.scrollTop = log.scrollHeight;
        }
      }
      battleState = null;
    }
  </script>
</body>
</html>